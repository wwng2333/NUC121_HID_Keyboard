; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\clk.crf ..\..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;27       */
;;;28     void CLK_DisableCKO(void)
000000  4803              LDR      r0,|L1.16|
;;;29     {
;;;30         /* Disable CKO clock source */
;;;31         CLK->APBCLK0 &= (~CLK_APBCLK0_CLKOCKEN_Msk);
000002  6880              LDR      r0,[r0,#8]
000004  2140              MOVS     r1,#0x40
000006  4388              BICS     r0,r0,r1
000008  4901              LDR      r1,|L1.16|
00000a  6088              STR      r0,[r1,#8]
;;;32     }
00000c  4770              BX       lr
;;;33     
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;516      */
;;;517    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;518    {
;;;519        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4b0d              LDR      r3,|L2.56|
000004  681a              LDR      r2,[r3,#0]  ; <Data3>
000006  6859              LDR      r1,[r3,#4]  ; <Data3>
000008  689b              LDR      r3,[r3,#8]  ; <Data3>
00000a  9302              STR      r3,[sp,#8]
00000c  9200              STR      r2,[sp,#0]
00000e  9101              STR      r1,[sp,#4]
;;;520    
;;;521        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000010  0f81              LSRS     r1,r0,#30
000012  0089              LSLS     r1,r1,#2
000014  466a              MOV      r2,sp
000016  5851              LDR      r1,[r2,r1]
000018  4a08              LDR      r2,|L2.60|
00001a  1889              ADDS     r1,r1,r2
00001c  6849              LDR      r1,[r1,#4]
00001e  06c3              LSLS     r3,r0,#27
000020  0edb              LSRS     r3,r3,#27
000022  2201              MOVS     r2,#1
000024  409a              LSLS     r2,r2,r3
000026  4391              BICS     r1,r1,r2
000028  0f82              LSRS     r2,r0,#30
00002a  0092              LSLS     r2,r2,#2
00002c  466b              MOV      r3,sp
00002e  589a              LDR      r2,[r3,r2]
000030  4b02              LDR      r3,|L2.60|
000032  18d2              ADDS     r2,r2,r3
000034  6051              STR      r1,[r2,#4]
;;;522    }
000036  bd0e              POP      {r1-r3,pc}
;;;523    
                          ENDP

                  |L2.56|
                          DCD      ||.constdata||+0x1c
                  |L2.60|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;663      */
;;;664    void CLK_DisablePLL(void)
000000  4803              LDR      r0,|L3.16|
;;;665    {
;;;666        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000002  6a00              LDR      r0,[r0,#0x20]
000004  2101              MOVS     r1,#1
000006  0409              LSLS     r1,r1,#16
000008  4308              ORRS     r0,r0,r1
00000a  4901              LDR      r1,|L3.16|
00000c  6208              STR      r0,[r1,#0x20]
;;;667    }
00000e  4770              BX       lr
;;;668    
                          ENDP

                  |L3.16|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;734      */
;;;735    void CLK_DisableSysTick(void)
000000  2000              MOVS     r0,#0
;;;736    {
;;;737        /* Set System Tick counter disabled */
;;;738        SysTick->CTRL = 0;
000002  4901              LDR      r1,|L4.8|
000004  6108              STR      r0,[r1,#0x10]
;;;739    }
000006  4770              BX       lr
;;;740    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;440      */
;;;441    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;442    {
;;;443        CLK->PWRCTL &= ~u32ClkMask;
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L5.12|
000008  6011              STR      r1,[r2,#0]
;;;444    }
00000a  4770              BX       lr
;;;445    
                          ENDP

                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;53       */
;;;54     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;57         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  2310              MOVS     r3,#0x10
000004  430b              ORRS     r3,r3,r1
000006  0154              LSLS     r4,r2,#5
000008  4323              ORRS     r3,r3,r4
00000a  4c08              LDR      r4,|L6.44|
00000c  6263              STR      r3,[r4,#0x24]
;;;58     
;;;59         /* Enable CKO clock source */
;;;60         CLK->APBCLK0 |= CLK_APBCLK0_CLKOCKEN_Msk;
00000e  4623              MOV      r3,r4
000010  689b              LDR      r3,[r3,#8]
000012  2440              MOVS     r4,#0x40
000014  4323              ORRS     r3,r3,r4
000016  4c05              LDR      r4,|L6.44|
000018  60a3              STR      r3,[r4,#8]
;;;61     
;;;62         /* Select CKO clock source */
;;;63         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_CLKOSEL_Msk)) | (u32ClkSrc);
00001a  4623              MOV      r3,r4
00001c  69db              LDR      r3,[r3,#0x1c]
00001e  241c              MOVS     r4,#0x1c
000020  43a3              BICS     r3,r3,r4
000022  4303              ORRS     r3,r3,r0
000024  4c01              LDR      r4,|L6.44|
000026  61e3              STR      r3,[r4,#0x1c]
;;;64     
;;;65     }
000028  bd10              POP      {r4,pc}
;;;66     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;477      */
;;;478    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;479    {
;;;480        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4b0d              LDR      r3,|L7.56|
000004  681a              LDR      r2,[r3,#0]  ; <Data2>
000006  6859              LDR      r1,[r3,#4]  ; <Data2>
000008  689b              LDR      r3,[r3,#8]  ; <Data2>
00000a  9302              STR      r3,[sp,#8]
00000c  9200              STR      r2,[sp,#0]
00000e  9101              STR      r1,[sp,#4]
;;;481    
;;;482        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000010  0f81              LSRS     r1,r0,#30
000012  0089              LSLS     r1,r1,#2
000014  466a              MOV      r2,sp
000016  5851              LDR      r1,[r2,r1]
000018  4a08              LDR      r2,|L7.60|
00001a  1889              ADDS     r1,r1,r2
00001c  6849              LDR      r1,[r1,#4]
00001e  06c3              LSLS     r3,r0,#27
000020  0edb              LSRS     r3,r3,#27
000022  2201              MOVS     r2,#1
000024  409a              LSLS     r2,r2,r3
000026  4311              ORRS     r1,r1,r2
000028  0f82              LSRS     r2,r0,#30
00002a  0092              LSLS     r2,r2,#2
00002c  466b              MOV      r3,sp
00002e  589a              LDR      r2,[r3,r2]
000030  4b02              LDR      r3,|L7.60|
000032  18d2              ADDS     r2,r2,r3
000034  6051              STR      r1,[r2,#4]
;;;483    }
000036  bd0e              POP      {r1-r3,pc}
;;;484    
                          ENDP

                  |L7.56|
                          DCD      ||.constdata||+0x10
                  |L7.60|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;535      */
;;;536    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;537    {
000002  b089              SUB      sp,sp,#0x24
000004  460c              MOV      r4,r1
;;;538        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;539        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;540    
;;;541        /* Disable PLL first to avoid unstable when setting PLL */
;;;542        CLK_DisablePLL();
000006  f7fffffe          BL       CLK_DisablePLL
;;;543    
;;;544        /* PLL source clock is from HXT */
;;;545        if (u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
00000a  9809              LDR      r0,[sp,#0x24]
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L8.48|
;;;546        {
;;;547            /* Enable HXT clock */
;;;548            CLK->PWRCTL = (CLK->PWRCTL & ~CLK_PWRCTL_XTLEN_Msk) | CLK_PWRCTL_HXTEN;
000010  4850              LDR      r0,|L8.340|
000012  6800              LDR      r0,[r0,#0]
000014  0880              LSRS     r0,r0,#2
000016  0080              LSLS     r0,r0,#2
000018  1c40              ADDS     r0,r0,#1
00001a  494e              LDR      r1,|L8.340|
00001c  6008              STR      r0,[r1,#0]
;;;549    
;;;550            /* Wait for HXT clock ready */
;;;551            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       CLK_WaitClockReady
;;;552    
;;;553            /* Select PLL source clock from HXT */
;;;554            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
000024  2000              MOVS     r0,#0
000026  9006              STR      r0,[sp,#0x18]
;;;555            u32PllSrcClk = __HXT;
000028  484b              LDR      r0,|L8.344|
00002a  9008              STR      r0,[sp,#0x20]
;;;556    
;;;557            /* u32NR start from 2 */
;;;558            u32NR = 2;
00002c  2502              MOVS     r5,#2
00002e  e00e              B        |L8.78|
                  |L8.48|
;;;559        }
;;;560    
;;;561        /* PLL source clock is from HIRC_DIV2 */
;;;562        else
;;;563        {
;;;564            /* Enable HIRC_DIV2 clock */
;;;565            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000030  4848              LDR      r0,|L8.340|
000032  6800              LDR      r0,[r0,#0]
000034  2104              MOVS     r1,#4
000036  4308              ORRS     r0,r0,r1
000038  4946              LDR      r1,|L8.340|
00003a  6008              STR      r0,[r1,#0]
;;;566    
;;;567            /* Wait for HIRC clock ready */
;;;568            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00003c  2010              MOVS     r0,#0x10
00003e  f7fffffe          BL       CLK_WaitClockReady
;;;569    
;;;570            /* Select PLL source clock from HIRC */
;;;571            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC_DIV2;
000042  2011              MOVS     r0,#0x11
000044  04c0              LSLS     r0,r0,#19
000046  9006              STR      r0,[sp,#0x18]
;;;572            u32PllSrcClk = __HIRC_DIV2;
000048  4844              LDR      r0,|L8.348|
00004a  9008              STR      r0,[sp,#0x20]
;;;573    
;;;574            /* u32NR start from 4 when FIN = 24MHz to avoid calculation overflow */
;;;575            u32NR = 4;
00004c  2504              MOVS     r5,#4
                  |L8.78|
;;;576        }
;;;577    
;;;578        /* Select "NO" according to request frequency */
;;;579        if ((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq > FREQ_250MHZ))
00004e  4844              LDR      r0,|L8.352|
000050  4284              CMP      r4,r0
000052  d804              BHI      |L8.94|
000054  1040              ASRS     r0,r0,#1
000056  4284              CMP      r4,r0
000058  d901              BLS      |L8.94|
;;;580        {
;;;581            u32NO = 0;
00005a  2700              MOVS     r7,#0
00005c  e012              B        |L8.132|
                  |L8.94|
;;;582        }
;;;583        else if ((u32PllFreq <= FREQ_250MHZ) && (u32PllFreq > FREQ_125MHZ))
00005e  4841              LDR      r0,|L8.356|
000060  4284              CMP      r4,r0
000062  d805              BHI      |L8.112|
000064  1040              ASRS     r0,r0,#1
000066  4284              CMP      r4,r0
000068  d902              BLS      |L8.112|
;;;584        {
;;;585            u32NO = 1;
00006a  2701              MOVS     r7,#1
;;;586            u32PllFreq = u32PllFreq << 1;
00006c  0064              LSLS     r4,r4,#1
00006e  e009              B        |L8.132|
                  |L8.112|
;;;587        }
;;;588        else if ((u32PllFreq <= FREQ_125MHZ) && (u32PllFreq >= FREQ_50MHZ))
000070  483d              LDR      r0,|L8.360|
000072  4284              CMP      r4,r0
000074  d805              BHI      |L8.130|
000076  483d              LDR      r0,|L8.364|
000078  4284              CMP      r4,r0
00007a  d302              BCC      |L8.130|
;;;589        {
;;;590            u32NO = 3;
00007c  2703              MOVS     r7,#3
;;;591            u32PllFreq = u32PllFreq << 2;
00007e  00a4              LSLS     r4,r4,#2
000080  e000              B        |L8.132|
                  |L8.130|
;;;592        }
;;;593        else
;;;594        {
;;;595            /* Wrong frequency request. Just return default setting. */
;;;596            goto lexit;
000082  e057              B        |L8.308|
                  |L8.132|
;;;597        }
;;;598    
;;;599        /* Find best solution */
;;;600        u32Min = (uint32_t) - 1;
000084  2000              MOVS     r0,#0
000086  43c0              MVNS     r0,r0
000088  9003              STR      r0,[sp,#0xc]
;;;601        u32MinNR = 0;
00008a  2000              MOVS     r0,#0
00008c  9001              STR      r0,[sp,#4]
;;;602        u32MinNF = 0;
00008e  9002              STR      r0,[sp,#8]
;;;603    
;;;604        for (; u32NR <= 33; u32NR++)
000090  e034              B        |L8.252|
                  |L8.146|
;;;605        {
;;;606            u32Tmp = u32PllSrcClk / u32NR;
000092  4629              MOV      r1,r5
000094  9808              LDR      r0,[sp,#0x20]
000096  f7fffffe          BL       __aeabi_uidivmod
00009a  9005              STR      r0,[sp,#0x14]
;;;607    
;;;608            if ((u32Tmp > 1600000) && (u32Tmp < 16000000))
00009c  4934              LDR      r1,|L8.368|
00009e  9805              LDR      r0,[sp,#0x14]
0000a0  4288              CMP      r0,r1
0000a2  d92a              BLS      |L8.250|
0000a4  4933              LDR      r1,|L8.372|
0000a6  9805              LDR      r0,[sp,#0x14]
0000a8  4288              CMP      r0,r1
0000aa  d226              BCS      |L8.250|
;;;609            {
;;;610                for (u32NF = 2; u32NF <= 513; u32NF++)
0000ac  2002              MOVS     r0,#2
0000ae  9007              STR      r0,[sp,#0x1c]
0000b0  e01e              B        |L8.240|
                  |L8.178|
;;;611                {
;;;612                    u32Tmp2 = u32Tmp * u32NF;
0000b2  9e05              LDR      r6,[sp,#0x14]
0000b4  9907              LDR      r1,[sp,#0x1c]
0000b6  434e              MULS     r6,r1,r6
;;;613    
;;;614                    if ((u32Tmp2 >= 200000000) && (u32Tmp2 <= 500000000))
0000b8  482f              LDR      r0,|L8.376|
0000ba  4286              CMP      r6,r0
0000bc  d315              BCC      |L8.234|
0000be  4828              LDR      r0,|L8.352|
0000c0  4286              CMP      r6,r0
0000c2  d812              BHI      |L8.234|
;;;615                    {
;;;616                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000c4  42a6              CMP      r6,r4
0000c6  d901              BLS      |L8.204|
0000c8  1b30              SUBS     r0,r6,r4
0000ca  e000              B        |L8.206|
                  |L8.204|
0000cc  1ba0              SUBS     r0,r4,r6
                  |L8.206|
0000ce  9004              STR      r0,[sp,#0x10]
;;;617    
;;;618                        if (u32Tmp3 < u32Min)
0000d0  9903              LDR      r1,[sp,#0xc]
0000d2  9804              LDR      r0,[sp,#0x10]
0000d4  4288              CMP      r0,r1
0000d6  d208              BCS      |L8.234|
;;;619                        {
;;;620                            u32Min = u32Tmp3;
0000d8  9804              LDR      r0,[sp,#0x10]
0000da  9003              STR      r0,[sp,#0xc]
;;;621                            u32MinNR = u32NR;
0000dc  9501              STR      r5,[sp,#4]
;;;622                            u32MinNF = u32NF;
0000de  9807              LDR      r0,[sp,#0x1c]
0000e0  9002              STR      r0,[sp,#8]
;;;623    
;;;624                            /* Break when get good results */
;;;625                            if (u32Min == 0)
0000e2  9803              LDR      r0,[sp,#0xc]
0000e4  2800              CMP      r0,#0
0000e6  d100              BNE      |L8.234|
;;;626                                break;
0000e8  e006              B        |L8.248|
                  |L8.234|
0000ea  9807              LDR      r0,[sp,#0x1c]         ;610
0000ec  1c40              ADDS     r0,r0,#1              ;610
0000ee  9007              STR      r0,[sp,#0x1c]         ;610
                  |L8.240|
0000f0  4922              LDR      r1,|L8.380|
0000f2  9807              LDR      r0,[sp,#0x1c]         ;610
0000f4  4288              CMP      r0,r1                 ;610
0000f6  d9dc              BLS      |L8.178|
                  |L8.248|
0000f8  bf00              NOP      
                  |L8.250|
0000fa  1c6d              ADDS     r5,r5,#1              ;604
                  |L8.252|
0000fc  2d21              CMP      r5,#0x21              ;604
0000fe  d9c8              BLS      |L8.146|
;;;627                        }
;;;628                    }
;;;629                }
;;;630            }
;;;631        }
;;;632    
;;;633        /* Enable and apply new PLL setting. */
;;;634        CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
000100  03b8              LSLS     r0,r7,#14
000102  9906              LDR      r1,[sp,#0x18]
000104  4308              ORRS     r0,r0,r1
000106  9901              LDR      r1,[sp,#4]
000108  1e89              SUBS     r1,r1,#2
00010a  0249              LSLS     r1,r1,#9
00010c  4308              ORRS     r0,r0,r1
00010e  9902              LDR      r1,[sp,#8]
000110  1e89              SUBS     r1,r1,#2
000112  4308              ORRS     r0,r0,r1
000114  490f              LDR      r1,|L8.340|
000116  6208              STR      r0,[r1,#0x20]
;;;635    
;;;636        /* Wait for PLL clock stable */
;;;637        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000118  2004              MOVS     r0,#4
00011a  f7fffffe          BL       CLK_WaitClockReady
;;;638    
;;;639        /* Return actual PLL output clock frequency */
;;;640        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
00011e  1c78              ADDS     r0,r7,#1
000120  9a01              LDR      r2,[sp,#4]
000122  4350              MULS     r0,r2,r0
000124  4601              MOV      r1,r0
000126  9808              LDR      r0,[sp,#0x20]
000128  f7fffffe          BL       __aeabi_uidivmod
00012c  9902              LDR      r1,[sp,#8]
00012e  4348              MULS     r0,r1,r0
                  |L8.304|
;;;641    
;;;642    lexit:
;;;643    
;;;644        /* Apply default PLL setting and return */
;;;645        if (u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;646            CLK->PLLCTL = CLK_PLLCTL_96MHz_HXT; /* 96MHz */
;;;647        else
;;;648            CLK->PLLCTL = CLK_PLLCTL_96MHz_HIRC_DIV2; /* 96MHz */
;;;649    
;;;650        /* Wait for PLL clock stable */
;;;651        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;652    
;;;653        return CLK_GetPLLClockFreq();
;;;654    
;;;655    }
000130  b00b              ADD      sp,sp,#0x2c
000132  bdf0              POP      {r4-r7,pc}
                  |L8.308|
000134  9809              LDR      r0,[sp,#0x24]         ;645
000136  2800              CMP      r0,#0                 ;645
000138  d103              BNE      |L8.322|
00013a  4811              LDR      r0,|L8.384|
00013c  4905              LDR      r1,|L8.340|
00013e  6208              STR      r0,[r1,#0x20]         ;646
000140  e002              B        |L8.328|
                  |L8.322|
000142  4810              LDR      r0,|L8.388|
000144  4903              LDR      r1,|L8.340|
000146  6208              STR      r0,[r1,#0x20]         ;648
                  |L8.328|
000148  2004              MOVS     r0,#4                 ;651
00014a  f7fffffe          BL       CLK_WaitClockReady
00014e  f7fffffe          BL       CLK_GetPLLClockFreq
000152  e7ed              B        |L8.304|
;;;656    
                          ENDP

                  |L8.340|
                          DCD      0x50000200
                  |L8.344|
                          DCD      0x00b71b00
                  |L8.348|
                          DCD      0x016e3600
                  |L8.352|
                          DCD      0x1dcd6500
                  |L8.356|
                          DCD      0x0ee6b280
                  |L8.360|
                          DCD      0x07735940
                  |L8.364|
                          DCD      0x02faf080
                  |L8.368|
                          DCD      0x00186a00
                  |L8.372|
                          DCD      0x00f42400
                  |L8.376|
                          DCD      0x0bebc200
                  |L8.380|
                          DCD      0x00000201
                  |L8.384|
                          DCD      0x0000c25e
                  |L8.388|
                          DCD      0x0088c22e

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;707      */
;;;708    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  2200              MOVS     r2,#0
;;;709    {
;;;710        /* Set System Tick counter disabled */
;;;711        SysTick->CTRL = 0;
000002  4b0f              LDR      r3,|L9.64|
000004  611a              STR      r2,[r3,#0x10]
;;;712    
;;;713        /* Set System Tick clock source */
;;;714        if (u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK)
000006  2804              CMP      r0,#4
000008  d106              BNE      |L9.24|
;;;715            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
00000a  461a              MOV      r2,r3
00000c  6912              LDR      r2,[r2,#0x10]
00000e  2304              MOVS     r3,#4
000010  431a              ORRS     r2,r2,r3
000012  4b0b              LDR      r3,|L9.64|
000014  611a              STR      r2,[r3,#0x10]
000016  e006              B        |L9.38|
                  |L9.24|
;;;716        else
;;;717            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000018  4a0a              LDR      r2,|L9.68|
00001a  6912              LDR      r2,[r2,#0x10]
00001c  2338              MOVS     r3,#0x38
00001e  439a              BICS     r2,r2,r3
000020  4302              ORRS     r2,r2,r0
000022  4b08              LDR      r3,|L9.68|
000024  611a              STR      r2,[r3,#0x10]
                  |L9.38|
;;;718    
;;;719        /* Set System Tick reload value */
;;;720        SysTick->LOAD = u32Count;
000026  4a06              LDR      r2,|L9.64|
000028  6151              STR      r1,[r2,#0x14]
;;;721    
;;;722        /* Clear System Tick current value and counter flag */
;;;723        SysTick->VAL = 0;
00002a  2200              MOVS     r2,#0
00002c  4b04              LDR      r3,|L9.64|
00002e  619a              STR      r2,[r3,#0x18]
;;;724    
;;;725        /* Set System Tick interrupt enabled and counter enabled */
;;;726        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000030  461a              MOV      r2,r3
000032  6912              LDR      r2,[r2,#0x10]
000034  2303              MOVS     r3,#3
000036  431a              ORRS     r2,r2,r3
000038  4b01              LDR      r3,|L9.64|
00003a  611a              STR      r2,[r3,#0x10]
;;;727    }
00003c  4770              BX       lr
;;;728    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0xe000e000
                  |L9.68|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;421      */
;;;422    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4907              LDR      r1,|L10.32|
;;;423    {
;;;424        if (((CLK->PWRCTL | u32ClkMask) & CLK_PWRCTL_XTLEN_Msk) == CLK_PWRCTL_XTLEN_Msk)
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  0789              LSLS     r1,r1,#30
000008  0f89              LSRS     r1,r1,#30
00000a  2903              CMP      r1,#3
00000c  d100              BNE      |L10.16|
                  |L10.14|
;;;425            return;
;;;426    
;;;427        CLK->PWRCTL |= u32ClkMask;
;;;428    }
00000e  4770              BX       lr
                  |L10.16|
000010  4903              LDR      r1,|L10.32|
000012  6809              LDR      r1,[r1,#0]            ;427
000014  4301              ORRS     r1,r1,r0              ;427
000016  4a02              LDR      r2,|L10.32|
000018  6011              STR      r1,[r2,#0]            ;427
00001a  bf00              NOP      
00001c  e7f7              B        |L10.14|
;;;429    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;194      */
;;;195    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;196    {
;;;197        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;198        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;199    }
00000a  bd10              POP      {r4,pc}
;;;200    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;150      */
;;;151    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;154        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;155    }
00000a  bd10              POP      {r4,pc}
;;;156    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;121      */
;;;122    uint32_t CLK_GetHXTFreq(void)
000000  4804              LDR      r0,|L13.20|
;;;123    {
;;;124        if (CLK->PWRCTL & CLK_PWRCTL_HXTEN)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L13.16|
;;;125            return __HXT;
00000c  4802              LDR      r0,|L13.24|
                  |L13.14|
;;;126        else
;;;127            return 0;
;;;128    }
00000e  4770              BX       lr
                  |L13.16|
000010  2000              MOVS     r0,#0                 ;127
000012  e7fc              B        |L13.14|
;;;129    
                          ENDP

                  |L13.20|
                          DCD      0x50000200
                  |L13.24|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;135      */
;;;136    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;137    {
;;;138        if (CLK->PWRCTL & CLK_PWRCTL_LXTEN)
000002  6800              LDR      r0,[r0,#0]
000004  2102              MOVS     r1,#2
000006  4008              ANDS     r0,r0,r1
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L14.16|
;;;139            return __LXT;
00000c  0388              LSLS     r0,r1,#14
                  |L14.14|
;;;140        else
;;;141            return 0;
;;;142    }
00000e  4770              BX       lr
                  |L14.16|
000010  2000              MOVS     r0,#0                 ;141
000012  e7fc              B        |L14.14|
;;;143    
                          ENDP

                  |L14.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;162      */
;;;163    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;164    {
;;;165        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;166    
;;;167        if (CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk)
000006  4806              LDR      r0,|L15.32|
000008  6900              LDR      r0,[r0,#0x10]
00000a  2140              MOVS     r1,#0x40
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d003              BEQ      |L15.26|
;;;168            return SystemCoreClock >> 1;
000012  4804              LDR      r0,|L15.36|
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  0840              LSRS     r0,r0,#1
                  |L15.24|
;;;169        else
;;;170            return SystemCoreClock;
;;;171    }
000018  bd10              POP      {r4,pc}
                  |L15.26|
00001a  4802              LDR      r0,|L15.36|
00001c  6800              LDR      r0,[r0,#0]            ;170  ; SystemCoreClock
00001e  e7fb              B        |L15.24|
;;;172    
                          ENDP

                  |L15.32|
                          DCD      0x50000200
                  |L15.36|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;178      */
;;;179    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;182    
;;;183        if (CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk)
000006  4806              LDR      r0,|L16.32|
000008  6900              LDR      r0,[r0,#0x10]
00000a  2180              MOVS     r1,#0x80
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d003              BEQ      |L16.26|
;;;184            return SystemCoreClock >> 1;
000012  4804              LDR      r0,|L16.36|
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  0840              LSRS     r0,r0,#1
                  |L16.24|
;;;185        else
;;;186            return SystemCoreClock;
;;;187    }
000018  bd10              POP      {r4,pc}
                  |L16.26|
00001a  4802              LDR      r0,|L16.36|
00001c  6800              LDR      r0,[r0,#0]            ;186  ; SystemCoreClock
00001e  e7fb              B        |L16.24|
;;;188    
                          ENDP

                  |L16.32|
                          DCD      0x50000200
                  |L16.36|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;344      */
;;;345    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;346    {
;;;347        uint32_t u32PllFreq = 0, u32PllReg;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;348        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;349        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000006  a01a              ADR      r0,|L17.112|
000008  6800              LDR      r0,[r0,#0]
00000a  9000              STR      r0,[sp,#0]
;;;350    
;;;351        u32PllReg = CLK->PLLCTL;
00000c  4819              LDR      r0,|L17.116|
00000e  6a04              LDR      r4,[r0,#0x20]
;;;352    
;;;353        if (u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000010  1300              ASRS     r0,r0,#12
000012  4020              ANDS     r0,r0,r4
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L17.28|
;;;354            return 0;           /* PLL is in power down mode or fix low */
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;355    
;;;356        if (u32PllReg & CLK_PLLCTL_PLLSRC_HIRC_DIV2)
;;;357            u32FIN = __HIRC_DIV2;    /* PLL source clock from HIRC_DIV2 */
;;;358        else
;;;359            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;360    
;;;361        if (u32PllReg & CLK_PLLCTL_BP_Msk)
;;;362            return u32FIN;      /* PLL is in bypass mode */
;;;363    
;;;364        /* PLL is output enabled in normal work mode */
;;;365        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;366        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;367        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;368    
;;;369        /* u32FIN is shifted 2 bits to avoid overflow */
;;;370        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;371    
;;;372        return u32PllFreq;
;;;373    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L17.28|
00001c  2011              MOVS     r0,#0x11              ;356
00001e  04c0              LSLS     r0,r0,#19             ;356
000020  4020              ANDS     r0,r0,r4              ;356
000022  2800              CMP      r0,#0                 ;356
000024  d001              BEQ      |L17.42|
000026  4d14              LDR      r5,|L17.120|
000028  e000              B        |L17.44|
                  |L17.42|
00002a  4d14              LDR      r5,|L17.124|
                  |L17.44|
00002c  2001              MOVS     r0,#1                 ;361
00002e  0440              LSLS     r0,r0,#17             ;361
000030  4020              ANDS     r0,r0,r4              ;361
000032  2800              CMP      r0,#0                 ;361
000034  d001              BEQ      |L17.58|
000036  4628              MOV      r0,r5                 ;362
000038  e7ef              B        |L17.26|
                  |L17.58|
00003a  2003              MOVS     r0,#3                 ;365
00003c  0380              LSLS     r0,r0,#14             ;365
00003e  4020              ANDS     r0,r0,r4              ;365
000040  0b80              LSRS     r0,r0,#14             ;365
000042  4669              MOV      r1,sp                 ;365
000044  5c0a              LDRB     r2,[r1,r0]            ;365
000046  9201              STR      r2,[sp,#4]            ;365
000048  05e0              LSLS     r0,r4,#23             ;366
00004a  0dc0              LSRS     r0,r0,#23             ;366
00004c  1c86              ADDS     r6,r0,#2              ;366
00004e  201f              MOVS     r0,#0x1f              ;367
000050  0240              LSLS     r0,r0,#9              ;367
000052  4020              ANDS     r0,r0,r4              ;367
000054  0a40              LSRS     r0,r0,#9              ;367
000056  1c87              ADDS     r7,r0,#2              ;367
000058  9a01              LDR      r2,[sp,#4]            ;370
00005a  437a              MULS     r2,r7,r2              ;370
00005c  4611              MOV      r1,r2                 ;370
00005e  08aa              LSRS     r2,r5,#2              ;370
000060  4372              MULS     r2,r6,r2              ;370
000062  4610              MOV      r0,r2                 ;370
000064  f7fffffe          BL       __aeabi_uidivmod
000068  0080              LSLS     r0,r0,#2              ;370
00006a  9002              STR      r0,[sp,#8]            ;370
00006c  9802              LDR      r0,[sp,#8]            ;372
00006e  e7d4              B        |L17.26|
;;;374    
                          ENDP

                  |L17.112|
000070  01020204          DCB      1,2,2,4
                  |L17.116|
                          DCD      0x50000200
                  |L17.120|
                          DCD      0x016e3600
                  |L17.124|
                          DCD      0x00b71b00

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;103      */
;;;104    void CLK_Idle(void)
000000  4806              LDR      r0,|L18.28|
;;;105    {
;;;106        /* Set the processor uses sleep as its low power mode */
;;;107        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6900              LDR      r0,[r0,#0x10]
000004  2104              MOVS     r1,#4
000006  4388              BICS     r0,r0,r1
000008  4904              LDR      r1,|L18.28|
00000a  6108              STR      r0,[r1,#0x10]
;;;108    
;;;109        /* Set chip in idle mode because of WFI command */
;;;110        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000c  4804              LDR      r0,|L18.32|
00000e  6800              LDR      r0,[r0,#0]
000010  2180              MOVS     r1,#0x80
000012  4388              BICS     r0,r0,r1
000014  4902              LDR      r1,|L18.32|
000016  6008              STR      r0,[r1,#0]
;;;111    
;;;112        /* Chip enter idle mode after CPU run WFI instruction */
;;;113        __WFI();
000018  bf30              WFI      
;;;114    }
00001a  4770              BX       lr
;;;115    
                          ENDP

                  |L18.28|
                          DCD      0xe000ed00
                  |L18.32|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;73       */
;;;74     void CLK_PowerDown(void)
000000  490b              LDR      r1,|L19.48|
;;;75     {
;;;76         uint32_t u32HIRCTRIMCTL;
;;;77     
;;;78         /* Set the processor uses deep sleep as its low power mode */
;;;79         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6909              LDR      r1,[r1,#0x10]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  4a09              LDR      r2,|L19.48|
00000a  6111              STR      r1,[r2,#0x10]
;;;80     
;;;81         /* Set system Power-down enabled */
;;;82         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk);
00000c  4909              LDR      r1,|L19.52|
00000e  6809              LDR      r1,[r1,#0]
000010  2280              MOVS     r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  4a07              LDR      r2,|L19.52|
000016  6011              STR      r1,[r2,#0]
;;;83     
;;;84         /* Store HIRC control register */
;;;85         u32HIRCTRIMCTL = SYS->IRCTCTL;
000018  4907              LDR      r1,|L19.56|
00001a  6808              LDR      r0,[r1,#0]
;;;86     
;;;87         /* Disable HIRC auto trim */
;;;88         SYS->IRCTCTL &= (~SYS_IRCTCTL_FREQSEL_Msk);
00001c  6809              LDR      r1,[r1,#0]
00001e  0889              LSRS     r1,r1,#2
000020  0089              LSLS     r1,r1,#2
000022  4a05              LDR      r2,|L19.56|
000024  6011              STR      r1,[r2,#0]
;;;89     
;;;90         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;91         __WFI();
000026  bf30              WFI      
;;;92     
;;;93         /* Restore HIRC control register */
;;;94         SYS->IRCTCTL = u32HIRCTRIMCTL;
000028  4611              MOV      r1,r2
00002a  6008              STR      r0,[r1,#0]
;;;95     }
00002c  4770              BX       lr
;;;96     
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      0xe000ed00
                  |L19.52|
                          DCD      0x50000200
                  |L19.56|
                          DCD      0x50000080

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;209      */
;;;210    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;211    {
000002  4604              MOV      r4,r0
;;;212        uint32_t u32HIRCSTB;
;;;213    
;;;214        /* Read HIRC clock source stable flag */
;;;215        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  4822              LDR      r0,|L20.144|
000006  68c0              LDR      r0,[r0,#0xc]
000008  2110              MOVS     r1,#0x10
00000a  4008              ANDS     r0,r0,r1
00000c  4605              MOV      r5,r0
;;;216    
;;;217        /* The range of u32Hclk is 25 MHz ~ 50 MHz */
;;;218        if (u32Hclk > FREQ_50MHZ)
00000e  4821              LDR      r0,|L20.148|
000010  4284              CMP      r4,r0
000012  d900              BLS      |L20.22|
;;;219            u32Hclk = FREQ_50MHZ;
000014  4604              MOV      r4,r0
                  |L20.22|
;;;220    
;;;221        if (u32Hclk < FREQ_25MHZ)
000016  4820              LDR      r0,|L20.152|
000018  4284              CMP      r4,r0
00001a  d200              BCS      |L20.30|
;;;222            u32Hclk = FREQ_25MHZ;
00001c  4604              MOV      r4,r0
                  |L20.30|
;;;223    
;;;224        /* Switch HCLK clock source to HIRC clock for safe */
;;;225        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00001e  481c              LDR      r0,|L20.144|
000020  6800              LDR      r0,[r0,#0]
000022  2104              MOVS     r1,#4
000024  4308              ORRS     r0,r0,r1
000026  491a              LDR      r1,|L20.144|
000028  6008              STR      r0,[r1,#0]
;;;226        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00002a  2010              MOVS     r0,#0x10
00002c  f7fffffe          BL       CLK_WaitClockReady
;;;227        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000030  4817              LDR      r0,|L20.144|
000032  6900              LDR      r0,[r0,#0x10]
000034  2107              MOVS     r1,#7
000036  4308              ORRS     r0,r0,r1
000038  4915              LDR      r1,|L20.144|
00003a  6108              STR      r0,[r1,#0x10]
;;;228        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
00003c  4608              MOV      r0,r1
00003e  6980              LDR      r0,[r0,#0x18]
000040  0900              LSRS     r0,r0,#4
000042  0100              LSLS     r0,r0,#4
000044  6188              STR      r0,[r1,#0x18]
;;;229    
;;;230        /* Configure PLL setting if HXT clock is stable */
;;;231        if (CLK->STATUS & CLK_STATUS_HXTSTB_Msk)
000046  4608              MOV      r0,r1
000048  68c0              LDR      r0,[r0,#0xc]
00004a  07c0              LSLS     r0,r0,#31
00004c  0fc0              LSRS     r0,r0,#31
00004e  2800              CMP      r0,#0
000050  d005              BEQ      |L20.94|
;;;232            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
000052  0061              LSLS     r1,r4,#1
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       CLK_EnablePLL
00005a  4604              MOV      r4,r0
00005c  e00a              B        |L20.116|
                  |L20.94|
;;;233    
;;;234        /* Configure PLL setting if HXT clock is not stable */
;;;235        else
;;;236        {
;;;237            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC_DIV2, (u32Hclk << 1));
00005e  0061              LSLS     r1,r4,#1
000060  2011              MOVS     r0,#0x11
000062  04c0              LSLS     r0,r0,#19
000064  f7fffffe          BL       CLK_EnablePLL
000068  4604              MOV      r4,r0
;;;238    
;;;239            /* Read HIRC clock source stable flag */
;;;240            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00006a  4809              LDR      r0,|L20.144|
00006c  68c0              LDR      r0,[r0,#0xc]
00006e  2110              MOVS     r1,#0x10
000070  4008              ANDS     r0,r0,r1
000072  4605              MOV      r5,r0
                  |L20.116|
;;;241        }
;;;242    
;;;243        /* Select HCLK clock source to PLL,
;;;244           Select HCLK clock source divider as 2
;;;245           and update system core clock
;;;246        */
;;;247        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
000074  2101              MOVS     r1,#1
000076  2002              MOVS     r0,#2
000078  f7fffffe          BL       CLK_SetHCLK
;;;248    
;;;249        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;250        if (u32HIRCSTB == 0)
00007c  2d00              CMP      r5,#0
00007e  d105              BNE      |L20.140|
;;;251            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000080  4803              LDR      r0,|L20.144|
000082  6800              LDR      r0,[r0,#0]
000084  2104              MOVS     r1,#4
000086  4388              BICS     r0,r0,r1
000088  4901              LDR      r1,|L20.144|
00008a  6008              STR      r0,[r1,#0]
                  |L20.140|
;;;252    
;;;253        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;254        return u32Hclk >> 1;
00008c  0860              LSRS     r0,r4,#1
;;;255    }
00008e  bd70              POP      {r4-r6,pc}
;;;256    
                          ENDP

                  |L20.144|
                          DCD      0x50000200
                  |L20.148|
                          DCD      0x02faf080
                  |L20.152|
                          DCD      0x017d7840

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;272      */
;;;273    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;275        uint32_t u32HIRCSTB;
;;;276    
;;;277        /* Read HIRC clock source stable flag */
;;;278        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000006  4816              LDR      r0,|L21.96|
000008  68c0              LDR      r0,[r0,#0xc]
00000a  2110              MOVS     r1,#0x10
00000c  4008              ANDS     r0,r0,r1
00000e  4606              MOV      r6,r0
;;;279    
;;;280        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;281        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000010  4813              LDR      r0,|L21.96|
000012  6800              LDR      r0,[r0,#0]
000014  2104              MOVS     r1,#4
000016  4308              ORRS     r0,r0,r1
000018  4911              LDR      r1,|L21.96|
00001a  6008              STR      r0,[r1,#0]
;;;282        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;283        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
000022  480f              LDR      r0,|L21.96|
000024  6900              LDR      r0,[r0,#0x10]
000026  08c0              LSRS     r0,r0,#3
000028  00c0              LSLS     r0,r0,#3
00002a  1d00              ADDS     r0,r0,#4
00002c  490c              LDR      r1,|L21.96|
00002e  6108              STR      r0,[r1,#0x10]
;;;284    
;;;285        /* Apply new Divider */
;;;286        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000030  4608              MOV      r0,r1
000032  6980              LDR      r0,[r0,#0x18]
000034  0900              LSRS     r0,r0,#4
000036  0100              LSLS     r0,r0,#4
000038  4328              ORRS     r0,r0,r5
00003a  6188              STR      r0,[r1,#0x18]
;;;287    
;;;288        /* Switch HCLK to new HCLK source */
;;;289        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  4608              MOV      r0,r1
00003e  6900              LDR      r0,[r0,#0x10]
000040  08c0              LSRS     r0,r0,#3
000042  00c0              LSLS     r0,r0,#3
000044  4320              ORRS     r0,r0,r4
000046  6108              STR      r0,[r1,#0x10]
;;;290    
;;;291        /* Update System Core Clock */
;;;292        SystemCoreClockUpdate();
000048  f7fffffe          BL       SystemCoreClockUpdate
;;;293    
;;;294        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;295        if (u32HIRCSTB == 0)
00004c  2e00              CMP      r6,#0
00004e  d105              BNE      |L21.92|
;;;296            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000050  4803              LDR      r0,|L21.96|
000052  6800              LDR      r0,[r0,#0]
000054  2104              MOVS     r1,#4
000056  4388              BICS     r0,r0,r1
000058  4901              LDR      r1,|L21.96|
00005a  6008              STR      r0,[r1,#0]
                  |L21.92|
;;;297    }
00005c  bd70              POP      {r4-r6,pc}
;;;298    /**
                          ENDP

00005e  0000              DCW      0x0000
                  |L21.96|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;365      */
;;;366    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;367    {
000002  b085              SUB      sp,sp,#0x14
;;;368        uint32_t u32sel = 0, u32div = 0;
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;369        uint32_t u32SelTbl[] = {0x0, 0x4, 0xC, 0x24};
000008  4c1a              LDR      r4,|L22.116|
00000a  4625              MOV      r5,r4
00000c  cde0              LDM      r5,{r5-r7}
00000e  68e4              LDR      r4,[r4,#0xc]  ; <Data1>
000010  9703              STR      r7,[sp,#0xc]
000012  9602              STR      r6,[sp,#8]
000014  9501              STR      r5,[sp,#4]
000016  9404              STR      r4,[sp,#0x10]
;;;370        uint32_t u32DivTbl[] = {0x0};
000018  2400              MOVS     r4,#0
00001a  9400              STR      r4,[sp,#0]
;;;371    
;;;372        if (MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
00001c  0384              LSLS     r4,r0,#14
00001e  0e24              LSRS     r4,r4,#24
000020  2c00              CMP      r4,#0
000022  d010              BEQ      |L22.70|
;;;373        {
;;;374            /* Get clock divider control register address */
;;;375            u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000024  0304              LSLS     r4,r0,#12
000026  0fa4              LSRS     r4,r4,#30
000028  00a4              LSLS     r4,r4,#2
00002a  466d              MOV      r5,sp
00002c  592c              LDR      r4,[r5,r4]
00002e  4d12              LDR      r5,|L22.120|
000030  1963              ADDS     r3,r4,r5
;;;376            /* Apply new divider */
;;;377            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000032  0384              LSLS     r4,r0,#14
000034  0e25              LSRS     r5,r4,#24
000036  0584              LSLS     r4,r0,#22
000038  0ee4              LSRS     r4,r4,#27
00003a  40a5              LSLS     r5,r5,r4
00003c  681c              LDR      r4,[r3,#0]
00003e  43ac              BICS     r4,r4,r5
000040  9d07              LDR      r5,[sp,#0x1c]
000042  432c              ORRS     r4,r4,r5
000044  601c              STR      r4,[r3,#0]
                  |L22.70|
;;;378        }
;;;379    
;;;380        if (MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000046  0104              LSLS     r4,r0,#4
000048  0f64              LSRS     r4,r4,#29
00004a  2c00              CMP      r4,#0
00004c  d010              BEQ      |L22.112|
;;;381        {
;;;382            /* Get clock select control register address */
;;;383            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
00004e  0084              LSLS     r4,r0,#2
000050  0fa4              LSRS     r4,r4,#30
000052  00a4              LSLS     r4,r4,#2
000054  ad01              ADD      r5,sp,#4
000056  592c              LDR      r4,[r5,r4]
000058  4d07              LDR      r5,|L22.120|
00005a  3d08              SUBS     r5,r5,#8
00005c  1962              ADDS     r2,r4,r5
;;;384            /* Set new clock selection setting */
;;;385            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
00005e  0104              LSLS     r4,r0,#4
000060  0f65              LSRS     r5,r4,#29
000062  01c4              LSLS     r4,r0,#7
000064  0ee4              LSRS     r4,r4,#27
000066  40a5              LSLS     r5,r5,r4
000068  6814              LDR      r4,[r2,#0]
00006a  43ac              BICS     r4,r4,r5
00006c  430c              ORRS     r4,r4,r1
00006e  6014              STR      r4,[r2,#0]
                  |L22.112|
;;;386        }
;;;387    }
000070  b008              ADD      sp,sp,#0x20
000072  bdf0              POP      {r4-r7,pc}
;;;388    
                          ENDP

                  |L22.116|
                          DCD      ||.constdata||
                  |L22.120|
                          DCD      0x50000218

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;400      */
;;;401    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4903              LDR      r1,|L23.16|
;;;402    {
;;;403        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6909              LDR      r1,[r1,#0x10]
000004  2238              MOVS     r2,#0x38
000006  4391              BICS     r1,r1,r2
000008  4301              ORRS     r1,r1,r0
00000a  4a01              LDR      r2,|L23.16|
00000c  6111              STR      r1,[r2,#0x10]
;;;404    }
00000e  4770              BX       lr
;;;405    
                          ENDP

                  |L23.16|
                          DCD      0x50000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;680      */
;;;681    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  4601              MOV      r1,r0
;;;682    {
;;;683        int32_t i32TimeOutCnt = 2160000;
000002  4a07              LDR      r2,|L24.32|
;;;684    
;;;685        while ((CLK->STATUS & u32ClkMask) != u32ClkMask)
000004  e005              B        |L24.18|
                  |L24.6|
;;;686        {
;;;687            if (i32TimeOutCnt-- <= 0)
000006  4610              MOV      r0,r2
000008  1e52              SUBS     r2,r2,#1
00000a  2800              CMP      r0,#0
00000c  dc01              BGT      |L24.18|
;;;688                return 0;
00000e  2000              MOVS     r0,#0
                  |L24.16|
;;;689        }
;;;690    
;;;691        return 1;
;;;692    }
000010  4770              BX       lr
                  |L24.18|
000012  4804              LDR      r0,|L24.36|
000014  68c0              LDR      r0,[r0,#0xc]          ;685
000016  4008              ANDS     r0,r0,r1              ;685
000018  4288              CMP      r0,r1                 ;685
00001a  d1f4              BNE      |L24.6|
00001c  2001              MOVS     r0,#1                 ;691
00001e  e7f7              B        |L24.16|
;;;693    
                          ENDP

                  |L24.32|
                          DCD      0x0020f580
                  |L24.36|
                          DCD      0x50000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000024
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 479
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hid_kb.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\hid_kb.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\hid_kb.crf ..\hid_kb.c]
                          THUMB

                          AREA ||i.EP2_Handler||, CODE, READONLY, ALIGN=2

                  EP2_Handler PROC
;;;170    
;;;171    void EP2_Handler(void)  /* Interrupt IN handler */
000000  2001              MOVS     r0,#1
;;;172    {
;;;173        g_u8EP2Ready = 1;
000002  4901              LDR      r1,|L1.8|
000004  7008              STRB     r0,[r1,#0]
;;;174    }
000006  4770              BX       lr
;;;175    
                          ENDP

                  |L1.8|
                          DCD      g_u8EP2Ready

                          AREA ||i.HID_ClassRequest||, CODE, READONLY, ALIGN=2

                  HID_ClassRequest PROC
;;;207    
;;;208    void HID_ClassRequest(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;209    {
;;;210        uint8_t au8Buf[8];
;;;211    
;;;212        USBD_GetSetupPacket(au8Buf);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       USBD_GetSetupPacket
;;;213    
;;;214        if (au8Buf[0] & 0x80)   /* request data transfer direction */
000008  4668              MOV      r0,sp
00000a  7800              LDRB     r0,[r0,#0]
00000c  2180              MOVS     r1,#0x80
00000e  4008              ANDS     r0,r0,r1
000010  2800              CMP      r0,#0
000012  d012              BEQ      |L2.58|
;;;215        {
;;;216            // Device to host
;;;217            switch (au8Buf[1])
000014  4668              MOV      r0,sp
000016  7840              LDRB     r0,[r0,#1]
000018  2801              CMP      r0,#1
00001a  d004              BEQ      |L2.38|
00001c  2802              CMP      r0,#2
00001e  d003              BEQ      |L2.40|
000020  2803              CMP      r0,#3
000022  d002              BEQ      |L2.42|
;;;218            {
;;;219            case GET_REPORT:
000024  bf00              NOP      
                  |L2.38|
;;;220    
;;;221            //             {
;;;222            //                 break;
;;;223            //             }
;;;224            case GET_IDLE:
000026  bf00              NOP      
                  |L2.40|
;;;225    
;;;226            //             {
;;;227            //                 break;
;;;228            //             }
;;;229            case GET_PROTOCOL:
000028  bf00              NOP      
                  |L2.42|
;;;230    
;;;231            //            {
;;;232            //                break;
;;;233            //            }
;;;234            default:
;;;235            {
;;;236                /* Setup error, stall the device */
;;;237                USBD_SetStall(EP0);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       USBD_SetStall
;;;238                USBD_SetStall(EP1);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       USBD_SetStall
;;;239                break;
000036  bf00              NOP      
000038  e034              B        |L2.164|
                  |L2.58|
;;;240            }
;;;241            }
;;;242        }
;;;243        else
;;;244        {
;;;245            // Host to device
;;;246            switch (au8Buf[1])
00003a  4668              MOV      r0,sp
00003c  7840              LDRB     r0,[r0,#1]
00003e  2809              CMP      r0,#9
000040  d004              BEQ      |L2.76|
000042  280a              CMP      r0,#0xa
000044  d014              BEQ      |L2.112|
000046  280b              CMP      r0,#0xb
000048  d124              BNE      |L2.148|
00004a  e01a              B        |L2.130|
                  |L2.76|
;;;247            {
;;;248            case SET_REPORT:
;;;249            {
;;;250                if (au8Buf[3] == 2)
00004c  4668              MOV      r0,sp
00004e  78c0              LDRB     r0,[r0,#3]
000050  2802              CMP      r0,#2
000052  d10c              BNE      |L2.110|
;;;251                {
;;;252                    /* Request Type = Output */
;;;253                    USBD_SET_DATA1(EP1);
000054  4814              LDR      r0,|L2.168|
000056  6980              LDR      r0,[r0,#0x18]
000058  2180              MOVS     r1,#0x80
00005a  4308              ORRS     r0,r0,r1
00005c  4912              LDR      r1,|L2.168|
00005e  6188              STR      r0,[r1,#0x18]
;;;254                    USBD_SET_PAYLOAD_LEN(EP1, au8Buf[6]);
000060  4668              MOV      r0,sp
000062  7980              LDRB     r0,[r0,#6]
000064  6148              STR      r0,[r1,#0x14]
;;;255    
;;;256                    /* Status stage */
;;;257                    USBD_PrepareCtrlIn(0, 0);
000066  2100              MOVS     r1,#0
000068  4608              MOV      r0,r1
00006a  f7fffffe          BL       USBD_PrepareCtrlIn
                  |L2.110|
;;;258                }
;;;259    
;;;260                break;
00006e  e018              B        |L2.162|
                  |L2.112|
;;;261            }
;;;262    
;;;263            case SET_IDLE:
;;;264            {
;;;265                /* Status stage */
;;;266                USBD_SET_DATA1(EP0);
000070  480d              LDR      r0,|L2.168|
000072  6880              LDR      r0,[r0,#8]
000074  2180              MOVS     r1,#0x80
000076  4308              ORRS     r0,r0,r1
000078  490b              LDR      r1,|L2.168|
00007a  6088              STR      r0,[r1,#8]
;;;267                USBD_SET_PAYLOAD_LEN(EP0, 0);
00007c  2000              MOVS     r0,#0
00007e  6048              STR      r0,[r1,#4]
;;;268                break;
000080  e00f              B        |L2.162|
                  |L2.130|
;;;269            }
;;;270    
;;;271            case SET_PROTOCOL:
;;;272            {
;;;273                USBD_SET_DATA1(EP0);
000082  4809              LDR      r0,|L2.168|
000084  6880              LDR      r0,[r0,#8]
000086  2180              MOVS     r1,#0x80
000088  4308              ORRS     r0,r0,r1
00008a  4907              LDR      r1,|L2.168|
00008c  6088              STR      r0,[r1,#8]
;;;274                USBD_SET_PAYLOAD_LEN(EP0, 0);
00008e  2000              MOVS     r0,#0
000090  6048              STR      r0,[r1,#4]
;;;275                break;
000092  e006              B        |L2.162|
                  |L2.148|
;;;276            }
;;;277    
;;;278            default:
;;;279            {
;;;280                // Stall
;;;281                /* Setup error, stall the device */
;;;282                USBD_SetStall(EP0);
000094  2000              MOVS     r0,#0
000096  f7fffffe          BL       USBD_SetStall
;;;283                USBD_SetStall(EP1);
00009a  2001              MOVS     r0,#1
00009c  f7fffffe          BL       USBD_SetStall
;;;284                break;
0000a0  bf00              NOP      
                  |L2.162|
0000a2  bf00              NOP                            ;260
                  |L2.164|
;;;285            }
;;;286            }
;;;287        }
;;;288    }
0000a4  bd1c              POP      {r2-r4,pc}
;;;289    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L2.168|
                          DCD      0x40060500

                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;182      */
;;;183    void HID_Init(void)
000000  2000              MOVS     r0,#0
;;;184    {
;;;185        /* Init setup packet buffer */
;;;186        /* Buffer range for setup packet -> [0 ~ 0x7] */
;;;187        USBD->STBUFSEG = SETUP_BUF_BASE;
000002  4909              LDR      r1,|L3.40|
000004  6188              STR      r0,[r1,#0x18]
;;;188    
;;;189        /*****************************************************/
;;;190        /* EP0 ==> control IN endpoint, address 0 */
;;;191        USBD_CONFIG_EP(EP0, USBD_CFG_CSTALL | USBD_CFG_EPMODE_IN | 0);
000006  2009              MOVS     r0,#9
000008  0180              LSLS     r0,r0,#6
00000a  4908              LDR      r1,|L3.44|
00000c  6088              STR      r0,[r1,#8]
;;;192        /* Buffer range for EP0 */
;;;193        USBD_SET_EP_BUF_ADDR(EP0, EP0_BUF_BASE);
00000e  2008              MOVS     r0,#8
000010  6008              STR      r0,[r1,#0]
;;;194    
;;;195        /* EP1 ==> control OUT endpoint, address 0 */
;;;196        USBD_CONFIG_EP(EP1, USBD_CFG_CSTALL | USBD_CFG_EPMODE_OUT | 0);
000012  2011              MOVS     r0,#0x11
000014  0140              LSLS     r0,r0,#5
000016  6188              STR      r0,[r1,#0x18]
;;;197        /* Buffer range for EP1 */
;;;198        USBD_SET_EP_BUF_ADDR(EP1, EP1_BUF_BASE);
000018  2008              MOVS     r0,#8
00001a  6108              STR      r0,[r1,#0x10]
;;;199    
;;;200        /*****************************************************/
;;;201        /* EP2 ==> Interrupt IN endpoint, address 1 */
;;;202        USBD_CONFIG_EP(EP2, USBD_CFG_EPMODE_IN | INT_IN_EP_NUM);
00001c  2041              MOVS     r0,#0x41
00001e  6288              STR      r0,[r1,#0x28]
;;;203        /* Buffer range for EP2 */
;;;204        USBD_SET_EP_BUF_ADDR(EP2, EP2_BUF_BASE);
000020  2010              MOVS     r0,#0x10
000022  6208              STR      r0,[r1,#0x20]
;;;205    
;;;206    }
000024  4770              BX       lr
;;;207    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40060000
                  |L3.44|
                          DCD      0x40060500

                          AREA ||i.USBD_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_IRQHandler PROC
;;;17     
;;;18     void USBD_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;19     {
;;;20         uint32_t u32IntSts = USBD_GET_INT_FLAG();
000002  485a              LDR      r0,|L4.364|
000004  6844              LDR      r4,[r0,#4]
;;;21         uint32_t u32State = USBD_GET_BUS_STATE();
000006  6900              LDR      r0,[r0,#0x10]
000008  0705              LSLS     r5,r0,#28
00000a  0f2d              LSRS     r5,r5,#28
;;;22     
;;;23         //------------------------------------------------------------------
;;;24         if (u32IntSts & USBD_INTSTS_FLDET)
00000c  2004              MOVS     r0,#4
00000e  4020              ANDS     r0,r0,r4
000010  2800              CMP      r0,#0
000012  d015              BEQ      |L4.64|
;;;25         {
;;;26             // Floating detect
;;;27             USBD_CLR_INT_FLAG(USBD_INTSTS_FLDET);
000014  2004              MOVS     r0,#4
000016  4955              LDR      r1,|L4.364|
000018  6048              STR      r0,[r1,#4]
;;;28     
;;;29             if (USBD_IS_ATTACHED())
00001a  4608              MOV      r0,r1
00001c  6940              LDR      r0,[r0,#0x14]
00001e  07c0              LSLS     r0,r0,#31
000020  0fc0              LSRS     r0,r0,#31
000022  2800              CMP      r0,#0
000024  d006              BEQ      |L4.52|
;;;30             {
;;;31                 /* USB Plug In */
;;;32                 USBD_ENABLE_USB();
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  2190              MOVS     r1,#0x90
00002c  4308              ORRS     r0,r0,r1
00002e  494f              LDR      r1,|L4.364|
000030  6108              STR      r0,[r1,#0x10]
000032  e005              B        |L4.64|
                  |L4.52|
;;;33             }
;;;34             else
;;;35             {
;;;36                 /* USB Un-plug */
;;;37                 USBD_DISABLE_USB();
000034  484d              LDR      r0,|L4.364|
000036  6900              LDR      r0,[r0,#0x10]
000038  2180              MOVS     r1,#0x80
00003a  4388              BICS     r0,r0,r1
00003c  494b              LDR      r1,|L4.364|
00003e  6108              STR      r0,[r1,#0x10]
                  |L4.64|
;;;38             }
;;;39         }
;;;40     
;;;41         //------------------------------------------------------------------
;;;42         if (u32IntSts & USBD_INTSTS_BUS)
000040  07e0              LSLS     r0,r4,#31
000042  0fc0              LSRS     r0,r0,#31
000044  2800              CMP      r0,#0
000046  d021              BEQ      |L4.140|
;;;43         {
;;;44             /* Clear event flag */
;;;45             USBD_CLR_INT_FLAG(USBD_INTSTS_BUS);
000048  2001              MOVS     r0,#1
00004a  4948              LDR      r1,|L4.364|
00004c  6048              STR      r0,[r1,#4]
;;;46     
;;;47             if (u32State & USBD_STATE_USBRST)
00004e  4028              ANDS     r0,r0,r5
000050  2800              CMP      r0,#0
000052  d007              BEQ      |L4.100|
;;;48             {
;;;49                 /* Bus reset */
;;;50                 USBD_ENABLE_USB();
000054  4608              MOV      r0,r1
000056  6900              LDR      r0,[r0,#0x10]
000058  2190              MOVS     r1,#0x90
00005a  4308              ORRS     r0,r0,r1
00005c  4943              LDR      r1,|L4.364|
00005e  6108              STR      r0,[r1,#0x10]
;;;51                 USBD_SwReset();
000060  f7fffffe          BL       USBD_SwReset
                  |L4.100|
;;;52             }
;;;53     
;;;54             if (u32State & USBD_STATE_SUSPEND)
000064  2002              MOVS     r0,#2
000066  4028              ANDS     r0,r0,r5
000068  2800              CMP      r0,#0
00006a  d005              BEQ      |L4.120|
;;;55             {
;;;56                 /* Enable USB but disable PHY */
;;;57                 USBD_DISABLE_PHY();
00006c  483f              LDR      r0,|L4.364|
00006e  6900              LDR      r0,[r0,#0x10]
000070  2110              MOVS     r1,#0x10
000072  4388              BICS     r0,r0,r1
000074  493d              LDR      r1,|L4.364|
000076  6108              STR      r0,[r1,#0x10]
                  |L4.120|
;;;58             }
;;;59     
;;;60             if (u32State & USBD_STATE_RESUME)
000078  2004              MOVS     r0,#4
00007a  4028              ANDS     r0,r0,r5
00007c  2800              CMP      r0,#0
00007e  d005              BEQ      |L4.140|
;;;61             {
;;;62                 /* Enable USB and enable PHY */
;;;63                 USBD_ENABLE_USB();
000080  483a              LDR      r0,|L4.364|
000082  6900              LDR      r0,[r0,#0x10]
000084  2190              MOVS     r1,#0x90
000086  4308              ORRS     r0,r0,r1
000088  4938              LDR      r1,|L4.364|
00008a  6108              STR      r0,[r1,#0x10]
                  |L4.140|
;;;64             }
;;;65     
;;;66     #ifdef SUPPORT_LPM
;;;67     
;;;68             if (u32State & USBD_STATE_L1SUSPEND)
;;;69             {
;;;70                 /*
;;;71                    TODO: Implement LPM SUSPEND flag here.
;;;72                          Recommend implementing the power-saving function in main loop.
;;;73                 */
;;;74             }
;;;75     
;;;76             if (u32State & USBD_STATE_L1RESUME)
;;;77             {
;;;78                 /*
;;;79                    TODO: Implement LPM RESUME flag here.
;;;80                 */
;;;81             }
;;;82     
;;;83     #endif
;;;84     
;;;85         }
;;;86     
;;;87         if (u32IntSts & USBD_INTSTS_NEVWKIF_Msk)
00008c  2008              MOVS     r0,#8
00008e  4020              ANDS     r0,r0,r4
000090  2800              CMP      r0,#0
000092  d002              BEQ      |L4.154|
;;;88         {
;;;89             /*Clear no-event wake up interrupt */
;;;90             USBD_CLR_INT_FLAG(USBD_INTSTS_NEVWKIF_Msk);
000094  2008              MOVS     r0,#8
000096  4935              LDR      r1,|L4.364|
000098  6048              STR      r0,[r1,#4]
                  |L4.154|
;;;91             /*
;;;92                TODO: Implement the function that will be executed when device is woken by non-USB event.
;;;93             */
;;;94         }
;;;95     
;;;96         //------------------------------------------------------------------
;;;97         if (u32IntSts & USBD_INTSTS_USB)
00009a  2002              MOVS     r0,#2
00009c  4020              ANDS     r0,r0,r4
00009e  2800              CMP      r0,#0
0000a0  d063              BEQ      |L4.362|
;;;98         {
;;;99             // USB event
;;;100            if (u32IntSts & USBD_INTSTS_SETUP)
0000a2  0fe0              LSRS     r0,r4,#31
0000a4  07c0              LSLS     r0,r0,#31
0000a6  2800              CMP      r0,#0
0000a8  d011              BEQ      |L4.206|
;;;101            {
;;;102                // Setup packet
;;;103                /* Clear event flag */
;;;104                USBD_CLR_INT_FLAG(USBD_INTSTS_SETUP);
0000aa  2001              MOVS     r0,#1
0000ac  07c0              LSLS     r0,r0,#31
0000ae  492f              LDR      r1,|L4.364|
0000b0  6048              STR      r0,[r1,#4]
;;;105    
;;;106                /* Clear the data IN/OUT ready flag of control end-points */
;;;107                USBD_STOP_TRANSACTION(EP0);
0000b2  482f              LDR      r0,|L4.368|
0000b4  68c0              LDR      r0,[r0,#0xc]
0000b6  2101              MOVS     r1,#1
0000b8  4308              ORRS     r0,r0,r1
0000ba  492d              LDR      r1,|L4.368|
0000bc  60c8              STR      r0,[r1,#0xc]
;;;108                USBD_STOP_TRANSACTION(EP1);
0000be  4608              MOV      r0,r1
0000c0  69c0              LDR      r0,[r0,#0x1c]
0000c2  2101              MOVS     r1,#1
0000c4  4308              ORRS     r0,r0,r1
0000c6  492a              LDR      r1,|L4.368|
0000c8  61c8              STR      r0,[r1,#0x1c]
;;;109    
;;;110                USBD_ProcessSetupPacket();
0000ca  f7fffffe          BL       USBD_ProcessSetupPacket
                  |L4.206|
;;;111            }
;;;112    
;;;113            // EP events
;;;114            if (u32IntSts & USBD_INTSTS_EP0)
0000ce  2001              MOVS     r0,#1
0000d0  0400              LSLS     r0,r0,#16
0000d2  4020              ANDS     r0,r0,r4
0000d4  2800              CMP      r0,#0
0000d6  d005              BEQ      |L4.228|
;;;115            {
;;;116                /* Clear event flag */
;;;117                USBD_CLR_INT_FLAG(USBD_INTSTS_EP0);
0000d8  2001              MOVS     r0,#1
0000da  0400              LSLS     r0,r0,#16
0000dc  4923              LDR      r1,|L4.364|
0000de  6048              STR      r0,[r1,#4]
;;;118                // control IN
;;;119                USBD_CtrlIn();
0000e0  f7fffffe          BL       USBD_CtrlIn
                  |L4.228|
;;;120            }
;;;121    
;;;122            if (u32IntSts & USBD_INTSTS_EP1)
0000e4  2001              MOVS     r0,#1
0000e6  0440              LSLS     r0,r0,#17
0000e8  4020              ANDS     r0,r0,r4
0000ea  2800              CMP      r0,#0
0000ec  d005              BEQ      |L4.250|
;;;123            {
;;;124                /* Clear event flag */
;;;125                USBD_CLR_INT_FLAG(USBD_INTSTS_EP1);
0000ee  2001              MOVS     r0,#1
0000f0  0440              LSLS     r0,r0,#17
0000f2  491e              LDR      r1,|L4.364|
0000f4  6048              STR      r0,[r1,#4]
;;;126    
;;;127                // control OUT
;;;128                USBD_CtrlOut();
0000f6  f7fffffe          BL       USBD_CtrlOut
                  |L4.250|
;;;129            }
;;;130    
;;;131            if (u32IntSts & USBD_INTSTS_EP2)
0000fa  2001              MOVS     r0,#1
0000fc  0480              LSLS     r0,r0,#18
0000fe  4020              ANDS     r0,r0,r4
000100  2800              CMP      r0,#0
000102  d005              BEQ      |L4.272|
;;;132            {
;;;133                /* Clear event flag */
;;;134                USBD_CLR_INT_FLAG(USBD_INTSTS_EP2);
000104  2001              MOVS     r0,#1
000106  0480              LSLS     r0,r0,#18
000108  4918              LDR      r1,|L4.364|
00010a  6048              STR      r0,[r1,#4]
;;;135                // Interrupt IN
;;;136                EP2_Handler();
00010c  f7fffffe          BL       EP2_Handler
                  |L4.272|
;;;137            }
;;;138    
;;;139            if (u32IntSts & USBD_INTSTS_EP3)
000110  2001              MOVS     r0,#1
000112  04c0              LSLS     r0,r0,#19
000114  4020              ANDS     r0,r0,r4
000116  2800              CMP      r0,#0
000118  d003              BEQ      |L4.290|
;;;140            {
;;;141                /* Clear event flag */
;;;142                USBD_CLR_INT_FLAG(USBD_INTSTS_EP3);
00011a  2001              MOVS     r0,#1
00011c  04c0              LSLS     r0,r0,#19
00011e  4913              LDR      r1,|L4.364|
000120  6048              STR      r0,[r1,#4]
                  |L4.290|
;;;143            }
;;;144    
;;;145            if (u32IntSts & USBD_INTSTS_EP4)
000122  2001              MOVS     r0,#1
000124  0500              LSLS     r0,r0,#20
000126  4020              ANDS     r0,r0,r4
000128  2800              CMP      r0,#0
00012a  d003              BEQ      |L4.308|
;;;146            {
;;;147                /* Clear event flag */
;;;148                USBD_CLR_INT_FLAG(USBD_INTSTS_EP4);
00012c  2001              MOVS     r0,#1
00012e  0500              LSLS     r0,r0,#20
000130  490e              LDR      r1,|L4.364|
000132  6048              STR      r0,[r1,#4]
                  |L4.308|
;;;149            }
;;;150    
;;;151            if (u32IntSts & USBD_INTSTS_EP5)
000134  2001              MOVS     r0,#1
000136  0540              LSLS     r0,r0,#21
000138  4020              ANDS     r0,r0,r4
00013a  2800              CMP      r0,#0
00013c  d003              BEQ      |L4.326|
;;;152            {
;;;153                /* Clear event flag */
;;;154                USBD_CLR_INT_FLAG(USBD_INTSTS_EP5);
00013e  2001              MOVS     r0,#1
000140  0540              LSLS     r0,r0,#21
000142  490a              LDR      r1,|L4.364|
000144  6048              STR      r0,[r1,#4]
                  |L4.326|
;;;155            }
;;;156    
;;;157            if (u32IntSts & USBD_INTSTS_EP6)
000146  2001              MOVS     r0,#1
000148  0580              LSLS     r0,r0,#22
00014a  4020              ANDS     r0,r0,r4
00014c  2800              CMP      r0,#0
00014e  d003              BEQ      |L4.344|
;;;158            {
;;;159                /* Clear event flag */
;;;160                USBD_CLR_INT_FLAG(USBD_INTSTS_EP6);
000150  2001              MOVS     r0,#1
000152  0580              LSLS     r0,r0,#22
000154  4905              LDR      r1,|L4.364|
000156  6048              STR      r0,[r1,#4]
                  |L4.344|
;;;161            }
;;;162    
;;;163            if (u32IntSts & USBD_INTSTS_EP7)
000158  2001              MOVS     r0,#1
00015a  05c0              LSLS     r0,r0,#23
00015c  4020              ANDS     r0,r0,r4
00015e  2800              CMP      r0,#0
000160  d003              BEQ      |L4.362|
;;;164            {
;;;165                /* Clear event flag */
;;;166                USBD_CLR_INT_FLAG(USBD_INTSTS_EP7);
000162  2001              MOVS     r0,#1
000164  05c0              LSLS     r0,r0,#23
000166  4901              LDR      r1,|L4.364|
000168  6048              STR      r0,[r1,#4]
                  |L4.362|
;;;167            }
;;;168        }
;;;169    }
00016a  bd70              POP      {r4-r6,pc}
;;;170    
                          ENDP

                  |L4.364|
                          DCD      0x40060000
                  |L4.368|
                          DCD      0x40060500

                          AREA ||i.USBD_SetStall||, CODE, READONLY, ALIGN=2

                  USBD_SetStall PROC
;;;605      */
;;;606    static __INLINE void USBD_SetStall(uint8_t epnum)
000000  b530              PUSH     {r4,r5,lr}
;;;607    {
000002  4603              MOV      r3,r0
;;;608        uint32_t u32CfgAddr;
;;;609        uint32_t u32Cfg;
;;;610        int i;
;;;611    
;;;612        for (i = 0; i < USBD_MAX_EP; i++)
000004  2100              MOVS     r1,#0
000006  e010              B        |L5.42|
                  |L5.8|
;;;613        {
;;;614            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
000008  010c              LSLS     r4,r1,#4
00000a  4d0a              LDR      r5,|L5.52|
00000c  1960              ADDS     r0,r4,r5
;;;615            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
00000e  6802              LDR      r2,[r0,#0]
;;;616    
;;;617            if ((u32Cfg & 0xf) == epnum)
000010  0714              LSLS     r4,r2,#28
000012  0f24              LSRS     r4,r4,#28
000014  429c              CMP      r4,r3
000016  d107              BNE      |L5.40|
;;;618            {
;;;619                u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
000018  010c              LSLS     r4,r1,#4
00001a  1d2d              ADDS     r5,r5,#4
00001c  1960              ADDS     r0,r4,r5
;;;620                u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
00001e  6802              LDR      r2,[r0,#0]
;;;621    
;;;622                *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
000020  2402              MOVS     r4,#2
000022  4314              ORRS     r4,r4,r2
000024  6004              STR      r4,[r0,#0]
;;;623                break;
000026  e002              B        |L5.46|
                  |L5.40|
000028  1c49              ADDS     r1,r1,#1              ;612
                  |L5.42|
00002a  2908              CMP      r1,#8                 ;612
00002c  dbec              BLT      |L5.8|
                  |L5.46|
00002e  bf00              NOP      
;;;624            }
;;;625        }
;;;626    }
000030  bd30              POP      {r4,r5,pc}
;;;627    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40060508

;*** Start embedded assembler ***

#line 1 "..\\hid_kb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_hid_kb_c_52947378____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_hid_kb_c_52947378____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_hid_kb_c_52947378____REVSH|
#line 479
|__asm___8_hid_kb_c_52947378____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

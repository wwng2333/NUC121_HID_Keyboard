; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\system_nuc121.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\system_nuc121.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\system_nuc121.crf ..\..\..\..\Library\Device\Nuvoton\NUC121\Source\system_NUC121.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;344      */
;;;345    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;346    {
;;;347        uint32_t u32PllFreq = 0, u32PllReg;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;348        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;349        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000006  a01a              ADR      r0,|L1.112|
000008  6800              LDR      r0,[r0,#0]
00000a  9000              STR      r0,[sp,#0]
;;;350    
;;;351        u32PllReg = CLK->PLLCTL;
00000c  4819              LDR      r0,|L1.116|
00000e  6a04              LDR      r4,[r0,#0x20]
;;;352    
;;;353        if (u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000010  1300              ASRS     r0,r0,#12
000012  4020              ANDS     r0,r0,r4
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L1.28|
;;;354            return 0;           /* PLL is in power down mode or fix low */
000018  2000              MOVS     r0,#0
                  |L1.26|
;;;355    
;;;356        if (u32PllReg & CLK_PLLCTL_PLLSRC_HIRC_DIV2)
;;;357            u32FIN = __HIRC_DIV2;    /* PLL source clock from HIRC_DIV2 */
;;;358        else
;;;359            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;360    
;;;361        if (u32PllReg & CLK_PLLCTL_BP_Msk)
;;;362            return u32FIN;      /* PLL is in bypass mode */
;;;363    
;;;364        /* PLL is output enabled in normal work mode */
;;;365        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;366        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;367        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;368    
;;;369        /* u32FIN is shifted 2 bits to avoid overflow */
;;;370        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;371    
;;;372        return u32PllFreq;
;;;373    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L1.28|
00001c  2011              MOVS     r0,#0x11              ;356
00001e  04c0              LSLS     r0,r0,#19             ;356
000020  4020              ANDS     r0,r0,r4              ;356
000022  2800              CMP      r0,#0                 ;356
000024  d001              BEQ      |L1.42|
000026  4d14              LDR      r5,|L1.120|
000028  e000              B        |L1.44|
                  |L1.42|
00002a  4d14              LDR      r5,|L1.124|
                  |L1.44|
00002c  2001              MOVS     r0,#1                 ;361
00002e  0440              LSLS     r0,r0,#17             ;361
000030  4020              ANDS     r0,r0,r4              ;361
000032  2800              CMP      r0,#0                 ;361
000034  d001              BEQ      |L1.58|
000036  4628              MOV      r0,r5                 ;362
000038  e7ef              B        |L1.26|
                  |L1.58|
00003a  2003              MOVS     r0,#3                 ;365
00003c  0380              LSLS     r0,r0,#14             ;365
00003e  4020              ANDS     r0,r0,r4              ;365
000040  0b80              LSRS     r0,r0,#14             ;365
000042  4669              MOV      r1,sp                 ;365
000044  5c0a              LDRB     r2,[r1,r0]            ;365
000046  9201              STR      r2,[sp,#4]            ;365
000048  05e0              LSLS     r0,r4,#23             ;366
00004a  0dc0              LSRS     r0,r0,#23             ;366
00004c  1c86              ADDS     r6,r0,#2              ;366
00004e  201f              MOVS     r0,#0x1f              ;367
000050  0240              LSLS     r0,r0,#9              ;367
000052  4020              ANDS     r0,r0,r4              ;367
000054  0a40              LSRS     r0,r0,#9              ;367
000056  1c87              ADDS     r7,r0,#2              ;367
000058  9a01              LDR      r2,[sp,#4]            ;370
00005a  437a              MULS     r2,r7,r2              ;370
00005c  4611              MOV      r1,r2                 ;370
00005e  08aa              LSRS     r2,r5,#2              ;370
000060  4372              MULS     r2,r6,r2              ;370
000062  4610              MOV      r0,r2                 ;370
000064  f7fffffe          BL       __aeabi_uidivmod
000068  0080              LSLS     r0,r0,#2              ;370
00006a  9002              STR      r0,[sp,#8]            ;370
00006c  9802              LDR      r0,[sp,#8]            ;372
00006e  e7d4              B        |L1.26|
;;;374    
                          ENDP

                  |L1.112|
000070  01020204          DCB      1,2,2,4
                  |L1.116|
                          DCD      0x50000200
                  |L1.120|
                          DCD      0x016e3600
                  |L1.124|
                          DCD      0x00b71b00

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;31      */
;;;32     void SystemCoreClockUpdate(void)
000000  b570              PUSH     {r4-r6,lr}
;;;33     {
;;;34         uint32_t u32Freq, u32ClkSrc;
;;;35         uint32_t u32HclkDiv;
;;;36     
;;;37         u32ClkSrc = CLK->CLKSEL0 & CLK_CLKSEL0_HCLKSEL_Msk;
000002  4817              LDR      r0,|L2.96|
000004  6900              LDR      r0,[r0,#0x10]
000006  0745              LSLS     r5,r0,#29
000008  0f6d              LSRS     r5,r5,#29
;;;38     
;;;39         /* Update PLL Clock */
;;;40         PllClock = CLK_GetPLLClockFreq();
00000a  f7fffffe          BL       CLK_GetPLLClockFreq
00000e  4915              LDR      r1,|L2.100|
000010  6008              STR      r0,[r1,#0]  ; PllClock
;;;41     
;;;42     
;;;43         switch (u32ClkSrc)
000012  2d02              CMP      r5,#2
000014  d002              BEQ      |L2.28|
000016  2d05              CMP      r5,#5
000018  d107              BNE      |L2.42|
00001a  e002              B        |L2.34|
                  |L2.28|
;;;44         {
;;;45         case CLK_CLKSEL0_HCLKSEL_PLL:
;;;46             u32Freq = PllClock;
00001c  4811              LDR      r0,|L2.100|
00001e  6804              LDR      r4,[r0,#0]  ; PllClock
;;;47             break;
000020  e007              B        |L2.50|
                  |L2.34|
;;;48     
;;;49         case CLK_CLKSEL0_HCLKSEL_PLL_DIV2:
;;;50             u32Freq = PllClock / 2;
000022  4810              LDR      r0,|L2.100|
000024  6800              LDR      r0,[r0,#0]  ; PllClock
000026  0844              LSRS     r4,r0,#1
;;;51             break;
000028  e003              B        |L2.50|
                  |L2.42|
;;;52     
;;;53         default:
;;;54             u32Freq = gau32ClkSrcTbl[u32ClkSrc];
00002a  00a8              LSLS     r0,r5,#2
00002c  490e              LDR      r1,|L2.104|
00002e  580c              LDR      r4,[r1,r0]
000030  bf00              NOP                            ;43
                  |L2.50|
000032  bf00              NOP                            ;47
;;;55         }
;;;56     
;;;57     
;;;58         u32HclkDiv = (CLK->CLKDIV0 & CLK_CLKDIV0_HCLKDIV_Msk) + 1;
000034  480a              LDR      r0,|L2.96|
000036  6980              LDR      r0,[r0,#0x18]
000038  0700              LSLS     r0,r0,#28
00003a  0f00              LSRS     r0,r0,#28
00003c  1c46              ADDS     r6,r0,#1
;;;59     
;;;60         /* Update System Core Clock */
;;;61         SystemCoreClock = u32Freq / u32HclkDiv;
00003e  4631              MOV      r1,r6
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       __aeabi_uidivmod
000046  4909              LDR      r1,|L2.108|
000048  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;62     
;;;63         CyclesPerUs = (SystemCoreClock + 500000) / 1000000;
00004a  4909              LDR      r1,|L2.112|
00004c  4807              LDR      r0,|L2.108|
00004e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000050  104a              ASRS     r2,r1,#1
000052  1880              ADDS     r0,r0,r2
000054  f7fffffe          BL       __aeabi_uidivmod
000058  4906              LDR      r1,|L2.116|
00005a  6008              STR      r0,[r1,#0]  ; CyclesPerUs
;;;64     }
00005c  bd70              POP      {r4-r6,pc}
;;;65     
                          ENDP

00005e  0000              DCW      0x0000
                  |L2.96|
                          DCD      0x50000200
                  |L2.100|
                          DCD      PllClock
                  |L2.104|
                          DCD      gau32ClkSrcTbl
                  |L2.108|
                          DCD      SystemCoreClock
                  |L2.112|
                          DCD      0x000f4240
                  |L2.116|
                          DCD      CyclesPerUs

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=1

                  SystemInit PROC
;;;75      */
;;;76     void SystemInit(void)
000000  4770              BX       lr
;;;77     {
;;;78     #ifdef INIT_SYSCLK_AT_BOOTING
;;;79         int32_t i32TimeoutCnt;
;;;80         uint32_t u32HclkSelect;
;;;81         int8_t i8IsPllEn;
;;;82     
;;;83         PllClock = 0;
;;;84         i8IsPllEn = 0;
;;;85         u32HclkSelect = CLK->CLKSEL0 & CLK_CLKSEL0_HCLKSEL_Msk;
;;;86     
;;;87         if (u32HclkSelect == CLK_CLKSEL0_HCLKSEL_HXT)
;;;88         {
;;;89             /* Set to 50MHz system clock frequency when clock source is from external 12MHz X'Tal*/
;;;90             CLK->PLLCTL = CLK_PLLCTL_50MHz_HXT;
;;;91     
;;;92             /* Waiting for PLL ready */
;;;93             i32TimeoutCnt = (__HXT / 1000); /* Timeout is about 1ms */
;;;94     
;;;95             while ((CLK->STATUS & CLK_STATUS_PLLSTB_Msk) == 0)
;;;96             {
;;;97                 if (i32TimeoutCnt-- <= 0)
;;;98                     break;
;;;99             }
;;;100    
;;;101            i8IsPllEn = 1;
;;;102        }
;;;103        else if (u32HclkSelect == CLK_CLKSEL0_HCLKSEL_HIRC_DIV2)
;;;104        {
;;;105            /* Set to 50MHz system clock frequency when clock source is from internal 48MHz RC clock */
;;;106            CLK->PLLCTL = CLK_PLLCTL_50MHz_HIRC_DIV2;
;;;107    
;;;108            /* Waiting for PLL ready */
;;;109            i32TimeoutCnt = (__HIRC_DVI2 / 1000); /* Timeout is about 1ms */
;;;110    
;;;111            while ((CLK->STATUS & CLK_STATUS_PLLSTB_Msk) == 0)
;;;112            {
;;;113                if (i32TimeoutCnt-- <= 0)
;;;114                    break;
;;;115            }
;;;116    
;;;117            i8IsPllEn = 1;
;;;118        }
;;;119    
;;;120        if (i8IsPllEn)
;;;121        {
;;;122            /* Set PLL as HCLK clock source (HCLK_S is locked setting)*/
;;;123            SYS_UnlockReg();
;;;124            CLK->CLKSEL0 = CLK_CLKSEL0_HCLKSEL_PLL;
;;;125            SYS_LockReg();
;;;126        }
;;;127    
;;;128    #endif
;;;129    }
;;;130    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  gau32ClkSrcTbl
                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x05b8d800
                          DCD      0x00002710
                          DCD      0x02dc6c00
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x016e3600

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x05b8d800
                  CyclesPerUs
                          DCD      0x00000060
                  PllClock
                          DCD      0x05b8d800

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC121\\Source\\system_NUC121.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_system_NUC121_c_5d646a67____REV16|
#line 464 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_system_NUC121_c_5d646a67____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_system_NUC121_c_5d646a67____REVSH|
#line 479
|__asm___15_system_NUC121_c_5d646a67____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

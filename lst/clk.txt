; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\clk.crf StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;27       */
;;;28     void CLK_DisableCKO(void)
000000  4803              LDR      r0,|L1.16|
;;;29     {
;;;30         /* Disable CKO clock source */
;;;31         CLK->APBCLK0 &= (~CLK_APBCLK0_CLKOCKEN_Msk);
000002  6880              LDR      r0,[r0,#8]
000004  2140              MOVS     r1,#0x40
000006  4388              BICS     r0,r0,r1
000008  4901              LDR      r1,|L1.16|
00000a  6088              STR      r0,[r1,#8]
;;;32     }
00000c  4770              BX       lr
;;;33     
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;502      */
;;;503    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;504    {
;;;505        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4b0d              LDR      r3,|L2.56|
000004  681a              LDR      r2,[r3,#0]  ; <Data3>
000006  6859              LDR      r1,[r3,#4]  ; <Data3>
000008  689b              LDR      r3,[r3,#8]  ; <Data3>
00000a  9302              STR      r3,[sp,#8]
00000c  9200              STR      r2,[sp,#0]
00000e  9101              STR      r1,[sp,#4]
;;;506    
;;;507        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000010  0f81              LSRS     r1,r0,#30
000012  0089              LSLS     r1,r1,#2
000014  466a              MOV      r2,sp
000016  5851              LDR      r1,[r2,r1]
000018  4a08              LDR      r2,|L2.60|
00001a  1889              ADDS     r1,r1,r2
00001c  6849              LDR      r1,[r1,#4]
00001e  06c3              LSLS     r3,r0,#27
000020  0edb              LSRS     r3,r3,#27
000022  2201              MOVS     r2,#1
000024  409a              LSLS     r2,r2,r3
000026  4391              BICS     r1,r1,r2
000028  0f82              LSRS     r2,r0,#30
00002a  0092              LSLS     r2,r2,#2
00002c  466b              MOV      r3,sp
00002e  589a              LDR      r2,[r3,r2]
000030  4b02              LDR      r3,|L2.60|
000032  18d2              ADDS     r2,r2,r3
000034  6051              STR      r1,[r2,#4]
;;;508    }
000036  bd0e              POP      {r1-r3,pc}
;;;509    
                          ENDP

                  |L2.56|
                          DCD      ||.constdata||+0x1c
                  |L2.60|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;635      */
;;;636    void CLK_DisablePLL(void)
000000  4803              LDR      r0,|L3.16|
;;;637    {
;;;638        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000002  6a00              LDR      r0,[r0,#0x20]
000004  2101              MOVS     r1,#1
000006  0409              LSLS     r1,r1,#16
000008  4308              ORRS     r0,r0,r1
00000a  4901              LDR      r1,|L3.16|
00000c  6208              STR      r0,[r1,#0x20]
;;;639    }
00000e  4770              BX       lr
;;;640    
                          ENDP

                  |L3.16|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;705      */
;;;706    void CLK_DisableSysTick(void)
000000  2000              MOVS     r0,#0
;;;707    {
;;;708        /* Set System Tick counter disabled */
;;;709        SysTick->CTRL = 0;
000002  4901              LDR      r1,|L4.8|
000004  6108              STR      r0,[r1,#0x10]
;;;710    }
000006  4770              BX       lr
;;;711    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;426      */
;;;427    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;428    {
;;;429        CLK->PWRCTL &= ~u32ClkMask;
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L5.12|
000008  6011              STR      r1,[r2,#0]
;;;430    }
00000a  4770              BX       lr
;;;431    
                          ENDP

                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;53       */
;;;54     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;57         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  2310              MOVS     r3,#0x10
000004  430b              ORRS     r3,r3,r1
000006  0154              LSLS     r4,r2,#5
000008  4323              ORRS     r3,r3,r4
00000a  4c08              LDR      r4,|L6.44|
00000c  6263              STR      r3,[r4,#0x24]
;;;58     
;;;59         /* Enable CKO clock source */
;;;60         CLK->APBCLK0 |= CLK_APBCLK0_CLKOCKEN_Msk;
00000e  4623              MOV      r3,r4
000010  689b              LDR      r3,[r3,#8]
000012  2440              MOVS     r4,#0x40
000014  4323              ORRS     r3,r3,r4
000016  4c05              LDR      r4,|L6.44|
000018  60a3              STR      r3,[r4,#8]
;;;61     
;;;62         /* Select CKO clock source */
;;;63         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_CLKOSEL_Msk)) | (u32ClkSrc);
00001a  4623              MOV      r3,r4
00001c  69db              LDR      r3,[r3,#0x1c]
00001e  241c              MOVS     r4,#0x1c
000020  43a3              BICS     r3,r3,r4
000022  4303              ORRS     r3,r3,r0
000024  4c01              LDR      r4,|L6.44|
000026  61e3              STR      r3,[r4,#0x1c]
;;;64     
;;;65     }
000028  bd10              POP      {r4,pc}
;;;66     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;463      */
;;;464    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;465    {
;;;466        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x2C};
000002  4b0d              LDR      r3,|L7.56|
000004  681a              LDR      r2,[r3,#0]  ; <Data2>
000006  6859              LDR      r1,[r3,#4]  ; <Data2>
000008  689b              LDR      r3,[r3,#8]  ; <Data2>
00000a  9302              STR      r3,[sp,#8]
00000c  9200              STR      r2,[sp,#0]
00000e  9101              STR      r1,[sp,#4]
;;;467    
;;;468        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000010  0f81              LSRS     r1,r0,#30
000012  0089              LSLS     r1,r1,#2
000014  466a              MOV      r2,sp
000016  5851              LDR      r1,[r2,r1]
000018  4a08              LDR      r2,|L7.60|
00001a  1889              ADDS     r1,r1,r2
00001c  6849              LDR      r1,[r1,#4]
00001e  06c3              LSLS     r3,r0,#27
000020  0edb              LSRS     r3,r3,#27
000022  2201              MOVS     r2,#1
000024  409a              LSLS     r2,r2,r3
000026  4311              ORRS     r1,r1,r2
000028  0f82              LSRS     r2,r0,#30
00002a  0092              LSLS     r2,r2,#2
00002c  466b              MOV      r3,sp
00002e  589a              LDR      r2,[r3,r2]
000030  4b02              LDR      r3,|L7.60|
000032  18d2              ADDS     r2,r2,r3
000034  6051              STR      r1,[r2,#4]
;;;469    }
000036  bd0e              POP      {r1-r3,pc}
;;;470    
                          ENDP

                  |L7.56|
                          DCD      ||.constdata||+0x10
                  |L7.60|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;521      */
;;;522    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;523    {
000002  b089              SUB      sp,sp,#0x24
000004  460c              MOV      r4,r1
;;;524        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;525        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;526    
;;;527        /* Disable PLL first to avoid unstable when setting PLL */
;;;528        CLK_DisablePLL();
000006  f7fffffe          BL       CLK_DisablePLL
;;;529    
;;;530        /* PLL source clock is from HXT */
;;;531        if (u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT) {
00000a  9809              LDR      r0,[sp,#0x24]
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L8.48|
;;;532            /* Enable HXT clock */
;;;533            CLK->PWRCTL = (CLK->PWRCTL & ~CLK_PWRCTL_XTLEN_Msk) | CLK_PWRCTL_HXTEN;
000010  4850              LDR      r0,|L8.340|
000012  6800              LDR      r0,[r0,#0]
000014  0880              LSRS     r0,r0,#2
000016  0080              LSLS     r0,r0,#2
000018  1c40              ADDS     r0,r0,#1
00001a  494e              LDR      r1,|L8.340|
00001c  6008              STR      r0,[r1,#0]
;;;534    
;;;535            /* Wait for HXT clock ready */
;;;536            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       CLK_WaitClockReady
;;;537    
;;;538            /* Select PLL source clock from HXT */
;;;539            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
000024  2000              MOVS     r0,#0
000026  9006              STR      r0,[sp,#0x18]
;;;540            u32PllSrcClk = __HXT;
000028  484b              LDR      r0,|L8.344|
00002a  9008              STR      r0,[sp,#0x20]
;;;541    
;;;542            /* u32NR start from 2 */
;;;543            u32NR = 2;
00002c  2502              MOVS     r5,#2
00002e  e00e              B        |L8.78|
                  |L8.48|
;;;544        }
;;;545    
;;;546        /* PLL source clock is from HIRC_DIV2 */
;;;547        else {
;;;548            /* Enable HIRC_DIV2 clock */
;;;549            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000030  4848              LDR      r0,|L8.340|
000032  6800              LDR      r0,[r0,#0]
000034  2104              MOVS     r1,#4
000036  4308              ORRS     r0,r0,r1
000038  4946              LDR      r1,|L8.340|
00003a  6008              STR      r0,[r1,#0]
;;;550    
;;;551            /* Wait for HIRC clock ready */
;;;552            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00003c  2010              MOVS     r0,#0x10
00003e  f7fffffe          BL       CLK_WaitClockReady
;;;553    
;;;554            /* Select PLL source clock from HIRC */
;;;555            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC_DIV2;
000042  2011              MOVS     r0,#0x11
000044  04c0              LSLS     r0,r0,#19
000046  9006              STR      r0,[sp,#0x18]
;;;556            u32PllSrcClk = __HIRC_DIV2;
000048  4844              LDR      r0,|L8.348|
00004a  9008              STR      r0,[sp,#0x20]
;;;557    
;;;558            /* u32NR start from 4 when FIN = 24MHz to avoid calculation overflow */
;;;559            u32NR = 4;
00004c  2504              MOVS     r5,#4
                  |L8.78|
;;;560        }
;;;561    
;;;562        /* Select "NO" according to request frequency */
;;;563        if ((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq > FREQ_250MHZ)) {
00004e  4844              LDR      r0,|L8.352|
000050  4284              CMP      r4,r0
000052  d804              BHI      |L8.94|
000054  1040              ASRS     r0,r0,#1
000056  4284              CMP      r4,r0
000058  d901              BLS      |L8.94|
;;;564            u32NO = 0;
00005a  2700              MOVS     r7,#0
00005c  e012              B        |L8.132|
                  |L8.94|
;;;565        } else if ((u32PllFreq <= FREQ_250MHZ) && (u32PllFreq > FREQ_125MHZ)) {
00005e  4841              LDR      r0,|L8.356|
000060  4284              CMP      r4,r0
000062  d805              BHI      |L8.112|
000064  1040              ASRS     r0,r0,#1
000066  4284              CMP      r4,r0
000068  d902              BLS      |L8.112|
;;;566            u32NO = 1;
00006a  2701              MOVS     r7,#1
;;;567            u32PllFreq = u32PllFreq << 1;
00006c  0064              LSLS     r4,r4,#1
00006e  e009              B        |L8.132|
                  |L8.112|
;;;568        } else if ((u32PllFreq <= FREQ_125MHZ) && (u32PllFreq >= FREQ_50MHZ)) {
000070  483d              LDR      r0,|L8.360|
000072  4284              CMP      r4,r0
000074  d805              BHI      |L8.130|
000076  483d              LDR      r0,|L8.364|
000078  4284              CMP      r4,r0
00007a  d302              BCC      |L8.130|
;;;569            u32NO = 3;
00007c  2703              MOVS     r7,#3
;;;570            u32PllFreq = u32PllFreq << 2;
00007e  00a4              LSLS     r4,r4,#2
000080  e000              B        |L8.132|
                  |L8.130|
;;;571        } else {
;;;572            /* Wrong frequency request. Just return default setting. */
;;;573            goto lexit;
000082  e057              B        |L8.308|
                  |L8.132|
;;;574        }
;;;575    
;;;576        /* Find best solution */
;;;577        u32Min = (uint32_t) - 1;
000084  2000              MOVS     r0,#0
000086  43c0              MVNS     r0,r0
000088  9003              STR      r0,[sp,#0xc]
;;;578        u32MinNR = 0;
00008a  2000              MOVS     r0,#0
00008c  9001              STR      r0,[sp,#4]
;;;579        u32MinNF = 0;
00008e  9002              STR      r0,[sp,#8]
;;;580    
;;;581        for (; u32NR <= 33; u32NR++) {
000090  e034              B        |L8.252|
                  |L8.146|
;;;582            u32Tmp = u32PllSrcClk / u32NR;
000092  4629              MOV      r1,r5
000094  9808              LDR      r0,[sp,#0x20]
000096  f7fffffe          BL       __aeabi_uidivmod
00009a  9005              STR      r0,[sp,#0x14]
;;;583    
;;;584            if ((u32Tmp > 1600000) && (u32Tmp < 16000000)) {
00009c  4934              LDR      r1,|L8.368|
00009e  9805              LDR      r0,[sp,#0x14]
0000a0  4288              CMP      r0,r1
0000a2  d92a              BLS      |L8.250|
0000a4  4933              LDR      r1,|L8.372|
0000a6  9805              LDR      r0,[sp,#0x14]
0000a8  4288              CMP      r0,r1
0000aa  d226              BCS      |L8.250|
;;;585                for (u32NF = 2; u32NF <= 513; u32NF++) {
0000ac  2002              MOVS     r0,#2
0000ae  9007              STR      r0,[sp,#0x1c]
0000b0  e01e              B        |L8.240|
                  |L8.178|
;;;586                    u32Tmp2 = u32Tmp * u32NF;
0000b2  9e05              LDR      r6,[sp,#0x14]
0000b4  9907              LDR      r1,[sp,#0x1c]
0000b6  434e              MULS     r6,r1,r6
;;;587    
;;;588                    if ((u32Tmp2 >= 200000000) && (u32Tmp2 <= 500000000)) {
0000b8  482f              LDR      r0,|L8.376|
0000ba  4286              CMP      r6,r0
0000bc  d315              BCC      |L8.234|
0000be  4828              LDR      r0,|L8.352|
0000c0  4286              CMP      r6,r0
0000c2  d812              BHI      |L8.234|
;;;589                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000c4  42a6              CMP      r6,r4
0000c6  d901              BLS      |L8.204|
0000c8  1b30              SUBS     r0,r6,r4
0000ca  e000              B        |L8.206|
                  |L8.204|
0000cc  1ba0              SUBS     r0,r4,r6
                  |L8.206|
0000ce  9004              STR      r0,[sp,#0x10]
;;;590    
;;;591                        if (u32Tmp3 < u32Min) {
0000d0  9903              LDR      r1,[sp,#0xc]
0000d2  9804              LDR      r0,[sp,#0x10]
0000d4  4288              CMP      r0,r1
0000d6  d208              BCS      |L8.234|
;;;592                            u32Min = u32Tmp3;
0000d8  9804              LDR      r0,[sp,#0x10]
0000da  9003              STR      r0,[sp,#0xc]
;;;593                            u32MinNR = u32NR;
0000dc  9501              STR      r5,[sp,#4]
;;;594                            u32MinNF = u32NF;
0000de  9807              LDR      r0,[sp,#0x1c]
0000e0  9002              STR      r0,[sp,#8]
;;;595    
;;;596                            /* Break when get good results */
;;;597                            if (u32Min == 0)
0000e2  9803              LDR      r0,[sp,#0xc]
0000e4  2800              CMP      r0,#0
0000e6  d100              BNE      |L8.234|
;;;598                                break;
0000e8  e006              B        |L8.248|
                  |L8.234|
0000ea  9807              LDR      r0,[sp,#0x1c]         ;585
0000ec  1c40              ADDS     r0,r0,#1              ;585
0000ee  9007              STR      r0,[sp,#0x1c]         ;585
                  |L8.240|
0000f0  4922              LDR      r1,|L8.380|
0000f2  9807              LDR      r0,[sp,#0x1c]         ;585
0000f4  4288              CMP      r0,r1                 ;585
0000f6  d9dc              BLS      |L8.178|
                  |L8.248|
0000f8  bf00              NOP      
                  |L8.250|
0000fa  1c6d              ADDS     r5,r5,#1              ;581
                  |L8.252|
0000fc  2d21              CMP      r5,#0x21              ;581
0000fe  d9c8              BLS      |L8.146|
;;;599                        }
;;;600                    }
;;;601                }
;;;602            }
;;;603        }
;;;604    
;;;605        /* Enable and apply new PLL setting. */
;;;606        CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
000100  03b8              LSLS     r0,r7,#14
000102  9906              LDR      r1,[sp,#0x18]
000104  4308              ORRS     r0,r0,r1
000106  9901              LDR      r1,[sp,#4]
000108  1e89              SUBS     r1,r1,#2
00010a  0249              LSLS     r1,r1,#9
00010c  4308              ORRS     r0,r0,r1
00010e  9902              LDR      r1,[sp,#8]
000110  1e89              SUBS     r1,r1,#2
000112  4308              ORRS     r0,r0,r1
000114  490f              LDR      r1,|L8.340|
000116  6208              STR      r0,[r1,#0x20]
;;;607    
;;;608        /* Wait for PLL clock stable */
;;;609        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000118  2004              MOVS     r0,#4
00011a  f7fffffe          BL       CLK_WaitClockReady
;;;610    
;;;611        /* Return actual PLL output clock frequency */
;;;612        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
00011e  1c78              ADDS     r0,r7,#1
000120  9a01              LDR      r2,[sp,#4]
000122  4350              MULS     r0,r2,r0
000124  4601              MOV      r1,r0
000126  9808              LDR      r0,[sp,#0x20]
000128  f7fffffe          BL       __aeabi_uidivmod
00012c  9902              LDR      r1,[sp,#8]
00012e  4348              MULS     r0,r1,r0
                  |L8.304|
;;;613    
;;;614    lexit:
;;;615    
;;;616        /* Apply default PLL setting and return */
;;;617        if (u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;618            CLK->PLLCTL = CLK_PLLCTL_96MHz_HXT; /* 96MHz */
;;;619        else
;;;620            CLK->PLLCTL = CLK_PLLCTL_96MHz_HIRC_DIV2; /* 96MHz */
;;;621    
;;;622        /* Wait for PLL clock stable */
;;;623        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;624    
;;;625        return CLK_GetPLLClockFreq();
;;;626    
;;;627    }
000130  b00b              ADD      sp,sp,#0x2c
000132  bdf0              POP      {r4-r7,pc}
                  |L8.308|
000134  9809              LDR      r0,[sp,#0x24]         ;617
000136  2800              CMP      r0,#0                 ;617
000138  d103              BNE      |L8.322|
00013a  4811              LDR      r0,|L8.384|
00013c  4905              LDR      r1,|L8.340|
00013e  6208              STR      r0,[r1,#0x20]         ;618
000140  e002              B        |L8.328|
                  |L8.322|
000142  4810              LDR      r0,|L8.388|
000144  4903              LDR      r1,|L8.340|
000146  6208              STR      r0,[r1,#0x20]         ;620
                  |L8.328|
000148  2004              MOVS     r0,#4                 ;623
00014a  f7fffffe          BL       CLK_WaitClockReady
00014e  f7fffffe          BL       CLK_GetPLLClockFreq
000152  e7ed              B        |L8.304|
;;;628    
                          ENDP

                  |L8.340|
                          DCD      0x50000200
                  |L8.344|
                          DCD      0x00b71b00
                  |L8.348|
                          DCD      0x016e3600
                  |L8.352|
                          DCD      0x1dcd6500
                  |L8.356|
                          DCD      0x0ee6b280
                  |L8.360|
                          DCD      0x07735940
                  |L8.364|
                          DCD      0x02faf080
                  |L8.368|
                          DCD      0x00186a00
                  |L8.372|
                          DCD      0x00f42400
                  |L8.376|
                          DCD      0x0bebc200
                  |L8.380|
                          DCD      0x00000201
                  |L8.384|
                          DCD      0x0000c25e
                  |L8.388|
                          DCD      0x0088c22e

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;678      */
;;;679    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  2200              MOVS     r2,#0
;;;680    {
;;;681        /* Set System Tick counter disabled */
;;;682        SysTick->CTRL = 0;
000002  4b0f              LDR      r3,|L9.64|
000004  611a              STR      r2,[r3,#0x10]
;;;683    
;;;684        /* Set System Tick clock source */
;;;685        if (u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK)
000006  2804              CMP      r0,#4
000008  d106              BNE      |L9.24|
;;;686            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
00000a  461a              MOV      r2,r3
00000c  6912              LDR      r2,[r2,#0x10]
00000e  2304              MOVS     r3,#4
000010  431a              ORRS     r2,r2,r3
000012  4b0b              LDR      r3,|L9.64|
000014  611a              STR      r2,[r3,#0x10]
000016  e006              B        |L9.38|
                  |L9.24|
;;;687        else
;;;688            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000018  4a0a              LDR      r2,|L9.68|
00001a  6912              LDR      r2,[r2,#0x10]
00001c  2338              MOVS     r3,#0x38
00001e  439a              BICS     r2,r2,r3
000020  4302              ORRS     r2,r2,r0
000022  4b08              LDR      r3,|L9.68|
000024  611a              STR      r2,[r3,#0x10]
                  |L9.38|
;;;689    
;;;690        /* Set System Tick reload value */
;;;691        SysTick->LOAD = u32Count;
000026  4a06              LDR      r2,|L9.64|
000028  6151              STR      r1,[r2,#0x14]
;;;692    
;;;693        /* Clear System Tick current value and counter flag */
;;;694        SysTick->VAL = 0;
00002a  2200              MOVS     r2,#0
00002c  4b04              LDR      r3,|L9.64|
00002e  619a              STR      r2,[r3,#0x18]
;;;695    
;;;696        /* Set System Tick interrupt enabled and counter enabled */
;;;697        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000030  461a              MOV      r2,r3
000032  6912              LDR      r2,[r2,#0x10]
000034  2303              MOVS     r3,#3
000036  431a              ORRS     r2,r2,r3
000038  4b01              LDR      r3,|L9.64|
00003a  611a              STR      r2,[r3,#0x10]
;;;698    }
00003c  4770              BX       lr
;;;699    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0xe000e000
                  |L9.68|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;407      */
;;;408    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4907              LDR      r1,|L10.32|
;;;409    {
;;;410        if (((CLK->PWRCTL | u32ClkMask) & CLK_PWRCTL_XTLEN_Msk) == CLK_PWRCTL_XTLEN_Msk)
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  0789              LSLS     r1,r1,#30
000008  0f89              LSRS     r1,r1,#30
00000a  2903              CMP      r1,#3
00000c  d100              BNE      |L10.16|
                  |L10.14|
;;;411            return;
;;;412    
;;;413        CLK->PWRCTL |= u32ClkMask;
;;;414    }
00000e  4770              BX       lr
                  |L10.16|
000010  4903              LDR      r1,|L10.32|
000012  6809              LDR      r1,[r1,#0]            ;413
000014  4301              ORRS     r1,r1,r0              ;413
000016  4a02              LDR      r2,|L10.32|
000018  6011              STR      r1,[r2,#0]            ;413
00001a  bf00              NOP      
00001c  e7f7              B        |L10.14|
;;;415    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;183      */
;;;184    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;187        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;188    }
00000a  bd10              POP      {r4,pc}
;;;189    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;139      */
;;;140    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;141    {
;;;142        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;143        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;144    }
00000a  bd10              POP      {r4,pc}
;;;145    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;110      */
;;;111    uint32_t CLK_GetHXTFreq(void)
000000  4804              LDR      r0,|L13.20|
;;;112    {
;;;113        if (CLK->PWRCTL & CLK_PWRCTL_HXTEN)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L13.16|
;;;114            return __HXT;
00000c  4802              LDR      r0,|L13.24|
                  |L13.14|
;;;115        else
;;;116            return 0;
;;;117    }
00000e  4770              BX       lr
                  |L13.16|
000010  2000              MOVS     r0,#0                 ;116
000012  e7fc              B        |L13.14|
;;;118    
                          ENDP

                  |L13.20|
                          DCD      0x50000200
                  |L13.24|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;124      */
;;;125    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;126    {
;;;127        if (CLK->PWRCTL & CLK_PWRCTL_LXTEN)
000002  6800              LDR      r0,[r0,#0]
000004  2102              MOVS     r1,#2
000006  4008              ANDS     r0,r0,r1
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L14.16|
;;;128            return __LXT;
00000c  0388              LSLS     r0,r1,#14
                  |L14.14|
;;;129        else
;;;130            return 0;
;;;131    }
00000e  4770              BX       lr
                  |L14.16|
000010  2000              MOVS     r0,#0                 ;130
000012  e7fc              B        |L14.14|
;;;132    
                          ENDP

                  |L14.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;151      */
;;;152    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;153    {
;;;154        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;155    
;;;156        if (CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk)
000006  4806              LDR      r0,|L15.32|
000008  6900              LDR      r0,[r0,#0x10]
00000a  2140              MOVS     r1,#0x40
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d003              BEQ      |L15.26|
;;;157            return SystemCoreClock >> 1;
000012  4804              LDR      r0,|L15.36|
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  0840              LSRS     r0,r0,#1
                  |L15.24|
;;;158        else
;;;159            return SystemCoreClock;
;;;160    }
000018  bd10              POP      {r4,pc}
                  |L15.26|
00001a  4802              LDR      r0,|L15.36|
00001c  6800              LDR      r0,[r0,#0]            ;159  ; SystemCoreClock
00001e  e7fb              B        |L15.24|
;;;161    
                          ENDP

                  |L15.32|
                          DCD      0x50000200
                  |L15.36|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;167      */
;;;168    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;171    
;;;172        if (CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk)
000006  4806              LDR      r0,|L16.32|
000008  6900              LDR      r0,[r0,#0x10]
00000a  2180              MOVS     r1,#0x80
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d003              BEQ      |L16.26|
;;;173            return SystemCoreClock >> 1;
000012  4804              LDR      r0,|L16.36|
000014  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000016  0840              LSRS     r0,r0,#1
                  |L16.24|
;;;174        else
;;;175            return SystemCoreClock;
;;;176    }
000018  bd10              POP      {r4,pc}
                  |L16.26|
00001a  4802              LDR      r0,|L16.36|
00001c  6800              LDR      r0,[r0,#0]            ;175  ; SystemCoreClock
00001e  e7fb              B        |L16.24|
;;;177    
                          ENDP

                  |L16.32|
                          DCD      0x50000200
                  |L16.36|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;343      */
;;;344    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;345    {
;;;346        uint32_t u32PllFreq = 0, u32PllReg;
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
;;;347        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;348        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000006  a01a              ADR      r0,|L17.112|
000008  6800              LDR      r0,[r0,#0]
00000a  9000              STR      r0,[sp,#0]
;;;349    
;;;350        u32PllReg = CLK->PLLCTL;
00000c  4819              LDR      r0,|L17.116|
00000e  6a04              LDR      r4,[r0,#0x20]
;;;351    
;;;352        if (u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000010  1300              ASRS     r0,r0,#12
000012  4020              ANDS     r0,r0,r4
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L17.28|
;;;353            return 0;           /* PLL is in power down mode or fix low */
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;354    
;;;355        if (u32PllReg & CLK_PLLCTL_PLLSRC_HIRC_DIV2)
;;;356            u32FIN = __HIRC_DIV2;    /* PLL source clock from HIRC_DIV2 */
;;;357        else
;;;358            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;359    
;;;360        if (u32PllReg & CLK_PLLCTL_BP_Msk)
;;;361            return u32FIN;      /* PLL is in bypass mode */
;;;362    
;;;363        /* PLL is output enabled in normal work mode */
;;;364        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;365        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;366        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;367    
;;;368        /* u32FIN is shifted 2 bits to avoid overflow */
;;;369        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;370    
;;;371        return u32PllFreq;
;;;372    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L17.28|
00001c  2011              MOVS     r0,#0x11              ;355
00001e  04c0              LSLS     r0,r0,#19             ;355
000020  4020              ANDS     r0,r0,r4              ;355
000022  2800              CMP      r0,#0                 ;355
000024  d001              BEQ      |L17.42|
000026  4d14              LDR      r5,|L17.120|
000028  e000              B        |L17.44|
                  |L17.42|
00002a  4d14              LDR      r5,|L17.124|
                  |L17.44|
00002c  2001              MOVS     r0,#1                 ;360
00002e  0440              LSLS     r0,r0,#17             ;360
000030  4020              ANDS     r0,r0,r4              ;360
000032  2800              CMP      r0,#0                 ;360
000034  d001              BEQ      |L17.58|
000036  4628              MOV      r0,r5                 ;361
000038  e7ef              B        |L17.26|
                  |L17.58|
00003a  2003              MOVS     r0,#3                 ;364
00003c  0380              LSLS     r0,r0,#14             ;364
00003e  4020              ANDS     r0,r0,r4              ;364
000040  0b80              LSRS     r0,r0,#14             ;364
000042  4669              MOV      r1,sp                 ;364
000044  5c0a              LDRB     r2,[r1,r0]            ;364
000046  9201              STR      r2,[sp,#4]            ;364
000048  05e0              LSLS     r0,r4,#23             ;365
00004a  0dc0              LSRS     r0,r0,#23             ;365
00004c  1c86              ADDS     r6,r0,#2              ;365
00004e  201f              MOVS     r0,#0x1f              ;366
000050  0240              LSLS     r0,r0,#9              ;366
000052  4020              ANDS     r0,r0,r4              ;366
000054  0a40              LSRS     r0,r0,#9              ;366
000056  1c87              ADDS     r7,r0,#2              ;366
000058  9a01              LDR      r2,[sp,#4]            ;369
00005a  437a              MULS     r2,r7,r2              ;369
00005c  4611              MOV      r1,r2                 ;369
00005e  08aa              LSRS     r2,r5,#2              ;369
000060  4372              MULS     r2,r6,r2              ;369
000062  4610              MOV      r0,r2                 ;369
000064  f7fffffe          BL       __aeabi_uidivmod
000068  0080              LSLS     r0,r0,#2              ;369
00006a  9002              STR      r0,[sp,#8]            ;369
00006c  9802              LDR      r0,[sp,#8]            ;371
00006e  e7d4              B        |L17.26|
;;;373    
                          ENDP

                  |L17.112|
000070  01020204          DCB      1,2,2,4
                  |L17.116|
                          DCD      0x50000200
                  |L17.120|
                          DCD      0x016e3600
                  |L17.124|
                          DCD      0x00b71b00

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;92       */
;;;93     void CLK_Idle(void)
000000  4806              LDR      r0,|L18.28|
;;;94     {
;;;95         /* Set the processor uses sleep as its low power mode */
;;;96         SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6900              LDR      r0,[r0,#0x10]
000004  2104              MOVS     r1,#4
000006  4388              BICS     r0,r0,r1
000008  4904              LDR      r1,|L18.28|
00000a  6108              STR      r0,[r1,#0x10]
;;;97     
;;;98         /* Set chip in idle mode because of WFI command */
;;;99         CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000c  4804              LDR      r0,|L18.32|
00000e  6800              LDR      r0,[r0,#0]
000010  2180              MOVS     r1,#0x80
000012  4388              BICS     r0,r0,r1
000014  4902              LDR      r1,|L18.32|
000016  6008              STR      r0,[r1,#0]
;;;100    
;;;101        /* Chip enter idle mode after CPU run WFI instruction */
;;;102        __WFI();
000018  bf30              WFI      
;;;103    }
00001a  4770              BX       lr
;;;104    
                          ENDP

                  |L18.28|
                          DCD      0xe000ed00
                  |L18.32|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;73       */
;;;74     void CLK_PowerDown(void)
000000  4806              LDR      r0,|L19.28|
;;;75     {
;;;76         /* Set the processor uses deep sleep as its low power mode */
;;;77         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6900              LDR      r0,[r0,#0x10]
000004  2104              MOVS     r1,#4
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L19.28|
00000a  6108              STR      r0,[r1,#0x10]
;;;78     
;;;79         /* Set system Power-down enabled */
;;;80         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk);
00000c  4804              LDR      r0,|L19.32|
00000e  6800              LDR      r0,[r0,#0]
000010  2180              MOVS     r1,#0x80
000012  4308              ORRS     r0,r0,r1
000014  4902              LDR      r1,|L19.32|
000016  6008              STR      r0,[r1,#0]
;;;81     
;;;82         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;83         __WFI();
000018  bf30              WFI      
;;;84     }
00001a  4770              BX       lr
;;;85     
                          ENDP

                  |L19.28|
                          DCD      0xe000ed00
                  |L19.32|
                          DCD      0x50000200

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;198      */
;;;199    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;200    {
000002  4604              MOV      r4,r0
;;;201        uint32_t u32HIRCSTB;
;;;202    
;;;203        /* Read HIRC clock source stable flag */
;;;204        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  4822              LDR      r0,|L20.144|
000006  68c0              LDR      r0,[r0,#0xc]
000008  2110              MOVS     r1,#0x10
00000a  4008              ANDS     r0,r0,r1
00000c  4605              MOV      r5,r0
;;;205    
;;;206        /* The range of u32Hclk is 25 MHz ~ 50 MHz */
;;;207        if (u32Hclk > FREQ_50MHZ)
00000e  4821              LDR      r0,|L20.148|
000010  4284              CMP      r4,r0
000012  d900              BLS      |L20.22|
;;;208            u32Hclk = FREQ_50MHZ;
000014  4604              MOV      r4,r0
                  |L20.22|
;;;209    
;;;210        if (u32Hclk < FREQ_25MHZ)
000016  4820              LDR      r0,|L20.152|
000018  4284              CMP      r4,r0
00001a  d200              BCS      |L20.30|
;;;211            u32Hclk = FREQ_25MHZ;
00001c  4604              MOV      r4,r0
                  |L20.30|
;;;212    
;;;213        /* Switch HCLK clock source to HIRC clock for safe */
;;;214        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00001e  481c              LDR      r0,|L20.144|
000020  6800              LDR      r0,[r0,#0]
000022  2104              MOVS     r1,#4
000024  4308              ORRS     r0,r0,r1
000026  491a              LDR      r1,|L20.144|
000028  6008              STR      r0,[r1,#0]
;;;215        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00002a  2010              MOVS     r0,#0x10
00002c  f7fffffe          BL       CLK_WaitClockReady
;;;216        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000030  4817              LDR      r0,|L20.144|
000032  6900              LDR      r0,[r0,#0x10]
000034  2107              MOVS     r1,#7
000036  4308              ORRS     r0,r0,r1
000038  4915              LDR      r1,|L20.144|
00003a  6108              STR      r0,[r1,#0x10]
;;;217        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
00003c  4608              MOV      r0,r1
00003e  6980              LDR      r0,[r0,#0x18]
000040  0900              LSRS     r0,r0,#4
000042  0100              LSLS     r0,r0,#4
000044  6188              STR      r0,[r1,#0x18]
;;;218    
;;;219        /* Configure PLL setting if HXT clock is stable */
;;;220        if (CLK->STATUS & CLK_STATUS_HXTSTB_Msk)
000046  4608              MOV      r0,r1
000048  68c0              LDR      r0,[r0,#0xc]
00004a  07c0              LSLS     r0,r0,#31
00004c  0fc0              LSRS     r0,r0,#31
00004e  2800              CMP      r0,#0
000050  d005              BEQ      |L20.94|
;;;221            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
000052  0061              LSLS     r1,r4,#1
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       CLK_EnablePLL
00005a  4604              MOV      r4,r0
00005c  e00a              B        |L20.116|
                  |L20.94|
;;;222    
;;;223        /* Configure PLL setting if HXT clock is not stable */
;;;224        else {
;;;225            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC_DIV2, (u32Hclk << 1));
00005e  0061              LSLS     r1,r4,#1
000060  2011              MOVS     r0,#0x11
000062  04c0              LSLS     r0,r0,#19
000064  f7fffffe          BL       CLK_EnablePLL
000068  4604              MOV      r4,r0
;;;226    
;;;227            /* Read HIRC clock source stable flag */
;;;228            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00006a  4809              LDR      r0,|L20.144|
00006c  68c0              LDR      r0,[r0,#0xc]
00006e  2110              MOVS     r1,#0x10
000070  4008              ANDS     r0,r0,r1
000072  4605              MOV      r5,r0
                  |L20.116|
;;;229        }
;;;230    
;;;231        /* Select HCLK clock source to PLL,
;;;232           Select HCLK clock source divider as 2
;;;233           and update system core clock
;;;234        */
;;;235        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
000074  2101              MOVS     r1,#1
000076  2002              MOVS     r0,#2
000078  f7fffffe          BL       CLK_SetHCLK
;;;236    
;;;237        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;238        if (u32HIRCSTB == 0)
00007c  2d00              CMP      r5,#0
00007e  d105              BNE      |L20.140|
;;;239            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000080  4803              LDR      r0,|L20.144|
000082  6800              LDR      r0,[r0,#0]
000084  2104              MOVS     r1,#4
000086  4388              BICS     r0,r0,r1
000088  4901              LDR      r1,|L20.144|
00008a  6008              STR      r0,[r1,#0]
                  |L20.140|
;;;240    
;;;241        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;242        return u32Hclk >> 1;
00008c  0860              LSRS     r0,r4,#1
;;;243    }
00008e  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  |L20.144|
                          DCD      0x50000200
                  |L20.148|
                          DCD      0x02faf080
                  |L20.152|
                          DCD      0x017d7840

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;260      */
;;;261    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;262    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;263        uint32_t u32HIRCSTB;
;;;264    
;;;265        /* Read HIRC clock source stable flag */
;;;266        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000006  4816              LDR      r0,|L21.96|
000008  68c0              LDR      r0,[r0,#0xc]
00000a  2110              MOVS     r1,#0x10
00000c  4008              ANDS     r0,r0,r1
00000e  4606              MOV      r6,r0
;;;267    
;;;268        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;269        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000010  4813              LDR      r0,|L21.96|
000012  6800              LDR      r0,[r0,#0]
000014  2104              MOVS     r1,#4
000016  4308              ORRS     r0,r0,r1
000018  4911              LDR      r1,|L21.96|
00001a  6008              STR      r0,[r1,#0]
;;;270        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;271        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
000022  480f              LDR      r0,|L21.96|
000024  6900              LDR      r0,[r0,#0x10]
000026  08c0              LSRS     r0,r0,#3
000028  00c0              LSLS     r0,r0,#3
00002a  1d00              ADDS     r0,r0,#4
00002c  490c              LDR      r1,|L21.96|
00002e  6108              STR      r0,[r1,#0x10]
;;;272    
;;;273        /* Apply new Divider */
;;;274        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000030  4608              MOV      r0,r1
000032  6980              LDR      r0,[r0,#0x18]
000034  0900              LSRS     r0,r0,#4
000036  0100              LSLS     r0,r0,#4
000038  4328              ORRS     r0,r0,r5
00003a  6188              STR      r0,[r1,#0x18]
;;;275    
;;;276        /* Switch HCLK to new HCLK source */
;;;277        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  4608              MOV      r0,r1
00003e  6900              LDR      r0,[r0,#0x10]
000040  08c0              LSRS     r0,r0,#3
000042  00c0              LSLS     r0,r0,#3
000044  4320              ORRS     r0,r0,r4
000046  6108              STR      r0,[r1,#0x10]
;;;278    
;;;279        /* Update System Core Clock */
;;;280        SystemCoreClockUpdate();
000048  f7fffffe          BL       SystemCoreClockUpdate
;;;281    
;;;282        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;283        if (u32HIRCSTB == 0)
00004c  2e00              CMP      r6,#0
00004e  d105              BNE      |L21.92|
;;;284            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000050  4803              LDR      r0,|L21.96|
000052  6800              LDR      r0,[r0,#0]
000054  2104              MOVS     r1,#4
000056  4388              BICS     r0,r0,r1
000058  4901              LDR      r1,|L21.96|
00005a  6008              STR      r0,[r1,#0]
                  |L21.92|
;;;285    }
00005c  bd70              POP      {r4-r6,pc}
;;;286    /**
                          ENDP

00005e  0000              DCW      0x0000
                  |L21.96|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;353      */
;;;354    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;355    {
000002  b085              SUB      sp,sp,#0x14
;;;356        uint32_t u32sel = 0, u32div = 0;
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;357        uint32_t u32SelTbl[] = {0x0, 0x4, 0xC, 0x24};
000008  4c1a              LDR      r4,|L22.116|
00000a  4625              MOV      r5,r4
00000c  cde0              LDM      r5,{r5-r7}
00000e  68e4              LDR      r4,[r4,#0xc]  ; <Data1>
000010  9703              STR      r7,[sp,#0xc]
000012  9602              STR      r6,[sp,#8]
000014  9501              STR      r5,[sp,#4]
000016  9404              STR      r4,[sp,#0x10]
;;;358        uint32_t u32DivTbl[] = {0x0};
000018  2400              MOVS     r4,#0
00001a  9400              STR      r4,[sp,#0]
;;;359    
;;;360        if (MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk) {
00001c  0384              LSLS     r4,r0,#14
00001e  0e24              LSRS     r4,r4,#24
000020  2c00              CMP      r4,#0
000022  d010              BEQ      |L22.70|
;;;361            /* Get clock divider control register address */
;;;362            u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000024  0304              LSLS     r4,r0,#12
000026  0fa4              LSRS     r4,r4,#30
000028  00a4              LSLS     r4,r4,#2
00002a  466d              MOV      r5,sp
00002c  592c              LDR      r4,[r5,r4]
00002e  4d12              LDR      r5,|L22.120|
000030  1963              ADDS     r3,r4,r5
;;;363            /* Apply new divider */
;;;364            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000032  0384              LSLS     r4,r0,#14
000034  0e25              LSRS     r5,r4,#24
000036  0584              LSLS     r4,r0,#22
000038  0ee4              LSRS     r4,r4,#27
00003a  40a5              LSLS     r5,r5,r4
00003c  681c              LDR      r4,[r3,#0]
00003e  43ac              BICS     r4,r4,r5
000040  9d07              LDR      r5,[sp,#0x1c]
000042  432c              ORRS     r4,r4,r5
000044  601c              STR      r4,[r3,#0]
                  |L22.70|
;;;365        }
;;;366    
;;;367        if (MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk) {
000046  0104              LSLS     r4,r0,#4
000048  0f64              LSRS     r4,r4,#29
00004a  2c00              CMP      r4,#0
00004c  d010              BEQ      |L22.112|
;;;368            /* Get clock select control register address */
;;;369            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
00004e  0084              LSLS     r4,r0,#2
000050  0fa4              LSRS     r4,r4,#30
000052  00a4              LSLS     r4,r4,#2
000054  ad01              ADD      r5,sp,#4
000056  592c              LDR      r4,[r5,r4]
000058  4d07              LDR      r5,|L22.120|
00005a  3d08              SUBS     r5,r5,#8
00005c  1962              ADDS     r2,r4,r5
;;;370            /* Set new clock selection setting */
;;;371            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
00005e  0104              LSLS     r4,r0,#4
000060  0f65              LSRS     r5,r4,#29
000062  01c4              LSLS     r4,r0,#7
000064  0ee4              LSRS     r4,r4,#27
000066  40a5              LSLS     r5,r5,r4
000068  6814              LDR      r4,[r2,#0]
00006a  43ac              BICS     r4,r4,r5
00006c  430c              ORRS     r4,r4,r1
00006e  6014              STR      r4,[r2,#0]
                  |L22.112|
;;;372        }
;;;373    }
000070  b008              ADD      sp,sp,#0x20
000072  bdf0              POP      {r4-r7,pc}
;;;374    
                          ENDP

                  |L22.116|
                          DCD      ||.constdata||
                  |L22.120|
                          DCD      0x50000218

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;386      */
;;;387    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4903              LDR      r1,|L23.16|
;;;388    {
;;;389        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6909              LDR      r1,[r1,#0x10]
000004  2238              MOVS     r2,#0x38
000006  4391              BICS     r1,r1,r2
000008  4301              ORRS     r1,r1,r0
00000a  4a01              LDR      r2,|L23.16|
00000c  6111              STR      r1,[r2,#0x10]
;;;390    }
00000e  4770              BX       lr
;;;391    
                          ENDP

                  |L23.16|
                          DCD      0x50000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;652      */
;;;653    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  4601              MOV      r1,r0
;;;654    {
;;;655        int32_t i32TimeOutCnt = 2160000;
000002  4a07              LDR      r2,|L24.32|
;;;656    
;;;657        while ((CLK->STATUS & u32ClkMask) != u32ClkMask) {
000004  e005              B        |L24.18|
                  |L24.6|
;;;658            if (i32TimeOutCnt-- <= 0)
000006  4610              MOV      r0,r2
000008  1e52              SUBS     r2,r2,#1
00000a  2800              CMP      r0,#0
00000c  dc01              BGT      |L24.18|
;;;659                return 0;
00000e  2000              MOVS     r0,#0
                  |L24.16|
;;;660        }
;;;661    
;;;662        return 1;
;;;663    }
000010  4770              BX       lr
                  |L24.18|
000012  4804              LDR      r0,|L24.36|
000014  68c0              LDR      r0,[r0,#0xc]          ;657
000016  4008              ANDS     r0,r0,r1              ;657
000018  4288              CMP      r0,r1                 ;657
00001a  d1f4              BNE      |L24.6|
00001c  2001              MOVS     r0,#1                 ;662
00001e  e7f7              B        |L24.16|
;;;664    
                          ENDP

                  |L24.32|
                          DCD      0x0020f580
                  |L24.36|
                          DCD      0x50000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000024
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c

;*** Start embedded assembler ***

#line 1 "StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 ".\\CMSIS\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

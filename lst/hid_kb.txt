; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hid_kb.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\hid_kb.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\hid_kb.crf hid_kb.c]
                          THUMB

                          AREA ||i.EP2_Handler||, CODE, READONLY, ALIGN=2

                  EP2_Handler PROC
;;;172    
;;;173    void EP2_Handler(void)  /* Interrupt IN handler */
000000  2001              MOVS     r0,#1
;;;174    {
;;;175        g_u8EP2Ready = 1;
000002  4901              LDR      r1,|L1.8|
000004  7008              STRB     r0,[r1,#0]
;;;176    }
000006  4770              BX       lr
;;;177    
                          ENDP

                  |L1.8|
                          DCD      g_u8EP2Ready

                          AREA ||i.HID_ClassRequest||, CODE, READONLY, ALIGN=2

                  HID_ClassRequest PROC
;;;208    
;;;209    void HID_ClassRequest(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;210    {
;;;211        uint8_t au8Buf[8];
;;;212    
;;;213        USBD_GetSetupPacket(au8Buf);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       USBD_GetSetupPacket
;;;214    
;;;215        if (au8Buf[0] & 0x80)   /* request data transfer direction */
000008  4668              MOV      r0,sp
00000a  7800              LDRB     r0,[r0,#0]
00000c  2180              MOVS     r1,#0x80
00000e  4008              ANDS     r0,r0,r1
000010  2800              CMP      r0,#0
000012  d012              BEQ      |L2.58|
;;;216        {
;;;217            // Device to host
;;;218            switch (au8Buf[1])
000014  4668              MOV      r0,sp
000016  7840              LDRB     r0,[r0,#1]
000018  2801              CMP      r0,#1
00001a  d004              BEQ      |L2.38|
00001c  2802              CMP      r0,#2
00001e  d003              BEQ      |L2.40|
000020  2803              CMP      r0,#3
000022  d002              BEQ      |L2.42|
;;;219            {
;;;220            case GET_REPORT:
000024  bf00              NOP      
                  |L2.38|
;;;221    
;;;222            //             {
;;;223            //                 break;
;;;224            //             }
;;;225            case GET_IDLE:
000026  bf00              NOP      
                  |L2.40|
;;;226    
;;;227            //             {
;;;228            //                 break;
;;;229            //             }
;;;230            case GET_PROTOCOL:
000028  bf00              NOP      
                  |L2.42|
;;;231    
;;;232            //            {
;;;233            //                break;
;;;234            //            }
;;;235            default:
;;;236            {
;;;237                /* Setup error, stall the device */
;;;238                USBD_SetStall(EP0);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       USBD_SetStall
;;;239                USBD_SetStall(EP1);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       USBD_SetStall
;;;240                break;
000036  bf00              NOP      
000038  e038              B        |L2.172|
                  |L2.58|
;;;241            }
;;;242            }
;;;243        }
;;;244        else
;;;245        {
;;;246            // Host to device
;;;247            switch (au8Buf[1])
00003a  4668              MOV      r0,sp
00003c  7840              LDRB     r0,[r0,#1]
00003e  2809              CMP      r0,#9
000040  d004              BEQ      |L2.76|
000042  280a              CMP      r0,#0xa
000044  d018              BEQ      |L2.120|
000046  280b              CMP      r0,#0xb
000048  d128              BNE      |L2.156|
00004a  e01e              B        |L2.138|
                  |L2.76|
;;;248            {
;;;249            case SET_REPORT:
;;;250            {
;;;251                if (au8Buf[3] == 2)
00004c  4668              MOV      r0,sp
00004e  78c0              LDRB     r0,[r0,#3]
000050  2802              CMP      r0,#2
000052  d110              BNE      |L2.118|
;;;252                {
;;;253    								USBD_PrepareCtrlOut((uint8_t *)&LED_Status[0], 1);
000054  2101              MOVS     r1,#1
000056  4816              LDR      r0,|L2.176|
000058  f7fffffe          BL       USBD_PrepareCtrlOut
;;;254    							
;;;255                    /* Request Type = Output */
;;;256                    USBD_SET_DATA1(EP1);
00005c  4815              LDR      r0,|L2.180|
00005e  6980              LDR      r0,[r0,#0x18]
000060  2180              MOVS     r1,#0x80
000062  4308              ORRS     r0,r0,r1
000064  4913              LDR      r1,|L2.180|
000066  6188              STR      r0,[r1,#0x18]
;;;257                    USBD_SET_PAYLOAD_LEN(EP1, au8Buf[6]);
000068  4668              MOV      r0,sp
00006a  7980              LDRB     r0,[r0,#6]
00006c  6148              STR      r0,[r1,#0x14]
;;;258    
;;;259                    /* Status stage */
;;;260                    USBD_PrepareCtrlIn(0, 0);
00006e  2100              MOVS     r1,#0
000070  4608              MOV      r0,r1
000072  f7fffffe          BL       USBD_PrepareCtrlIn
                  |L2.118|
;;;261                }
;;;262    
;;;263                break;
000076  e018              B        |L2.170|
                  |L2.120|
;;;264            }
;;;265    
;;;266            case SET_IDLE:
;;;267            {
;;;268                /* Status stage */
;;;269                USBD_SET_DATA1(EP0);
000078  480e              LDR      r0,|L2.180|
00007a  6880              LDR      r0,[r0,#8]
00007c  2180              MOVS     r1,#0x80
00007e  4308              ORRS     r0,r0,r1
000080  490c              LDR      r1,|L2.180|
000082  6088              STR      r0,[r1,#8]
;;;270                USBD_SET_PAYLOAD_LEN(EP0, 0);
000084  2000              MOVS     r0,#0
000086  6048              STR      r0,[r1,#4]
;;;271                break;
000088  e00f              B        |L2.170|
                  |L2.138|
;;;272            }
;;;273    
;;;274            case SET_PROTOCOL:
;;;275            {
;;;276                USBD_SET_DATA1(EP0);
00008a  480a              LDR      r0,|L2.180|
00008c  6880              LDR      r0,[r0,#8]
00008e  2180              MOVS     r1,#0x80
000090  4308              ORRS     r0,r0,r1
000092  4908              LDR      r1,|L2.180|
000094  6088              STR      r0,[r1,#8]
;;;277                USBD_SET_PAYLOAD_LEN(EP0, 0);
000096  2000              MOVS     r0,#0
000098  6048              STR      r0,[r1,#4]
;;;278                break;
00009a  e006              B        |L2.170|
                  |L2.156|
;;;279            }
;;;280    
;;;281            default:
;;;282            {
;;;283                // Stall
;;;284                /* Setup error, stall the device */
;;;285                USBD_SetStall(EP0);
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       USBD_SetStall
;;;286                USBD_SetStall(EP1);
0000a2  2001              MOVS     r0,#1
0000a4  f7fffffe          BL       USBD_SetStall
;;;287                break;
0000a8  bf00              NOP      
                  |L2.170|
0000aa  bf00              NOP                            ;263
                  |L2.172|
;;;288            }
;;;289            }
;;;290        }
;;;291    }
0000ac  bd1c              POP      {r2-r4,pc}
;;;292    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L2.176|
                          DCD      LED_Status
                  |L2.180|
                          DCD      0x40060500

                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;183      */
;;;184    void HID_Init(void)
000000  2000              MOVS     r0,#0
;;;185    {
;;;186        /* Init setup packet buffer */
;;;187        /* Buffer range for setup packet -> [0 ~ 0x7] */
;;;188        USBD->STBUFSEG = SETUP_BUF_BASE;
000002  4909              LDR      r1,|L3.40|
000004  6188              STR      r0,[r1,#0x18]
;;;189    
;;;190        /*****************************************************/
;;;191        /* EP0 ==> control IN endpoint, address 0 */
;;;192        USBD_CONFIG_EP(EP0, USBD_CFG_CSTALL | USBD_CFG_EPMODE_IN | 0);
000006  2009              MOVS     r0,#9
000008  0180              LSLS     r0,r0,#6
00000a  4908              LDR      r1,|L3.44|
00000c  6088              STR      r0,[r1,#8]
;;;193        /* Buffer range for EP0 */
;;;194        USBD_SET_EP_BUF_ADDR(EP0, EP0_BUF_BASE);
00000e  2008              MOVS     r0,#8
000010  6008              STR      r0,[r1,#0]
;;;195    
;;;196        /* EP1 ==> control OUT endpoint, address 0 */
;;;197        USBD_CONFIG_EP(EP1, USBD_CFG_CSTALL | USBD_CFG_EPMODE_OUT | 0);
000012  2011              MOVS     r0,#0x11
000014  0140              LSLS     r0,r0,#5
000016  6188              STR      r0,[r1,#0x18]
;;;198        /* Buffer range for EP1 */
;;;199        USBD_SET_EP_BUF_ADDR(EP1, EP1_BUF_BASE);
000018  2008              MOVS     r0,#8
00001a  6108              STR      r0,[r1,#0x10]
;;;200    
;;;201        /*****************************************************/
;;;202        /* EP2 ==> Interrupt IN endpoint, address 1 */
;;;203        USBD_CONFIG_EP(EP2, USBD_CFG_EPMODE_IN | INT_IN_EP_NUM);
00001c  2041              MOVS     r0,#0x41
00001e  6288              STR      r0,[r1,#0x28]
;;;204        /* Buffer range for EP2 */
;;;205        USBD_SET_EP_BUF_ADDR(EP2, EP2_BUF_BASE);
000020  2010              MOVS     r0,#0x10
000022  6208              STR      r0,[r1,#0x20]
;;;206    
;;;207    }
000024  4770              BX       lr
;;;208    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40060000
                  |L3.44|
                          DCD      0x40060500

                          AREA ||i.USBD_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_IRQHandler PROC
;;;17     
;;;18     void USBD_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;19     {
;;;20         uint32_t u32IntSts = USBD_GET_INT_FLAG();
000002  485b              LDR      r0,|L4.368|
000004  6844              LDR      r4,[r0,#4]
;;;21         uint32_t u32State = USBD_GET_BUS_STATE();
000006  6900              LDR      r0,[r0,#0x10]
000008  0705              LSLS     r5,r0,#28
00000a  0f2d              LSRS     r5,r5,#28
;;;22     
;;;23         //------------------------------------------------------------------
;;;24         if (u32IntSts & USBD_INTSTS_FLDET)
00000c  2004              MOVS     r0,#4
00000e  4020              ANDS     r0,r0,r4
000010  2800              CMP      r0,#0
000012  d015              BEQ      |L4.64|
;;;25         {
;;;26             // Floating detect
;;;27             USBD_CLR_INT_FLAG(USBD_INTSTS_FLDET);
000014  2004              MOVS     r0,#4
000016  4956              LDR      r1,|L4.368|
000018  6048              STR      r0,[r1,#4]
;;;28     
;;;29             if (USBD_IS_ATTACHED())
00001a  4608              MOV      r0,r1
00001c  6940              LDR      r0,[r0,#0x14]
00001e  07c0              LSLS     r0,r0,#31
000020  0fc0              LSRS     r0,r0,#31
000022  2800              CMP      r0,#0
000024  d006              BEQ      |L4.52|
;;;30             {
;;;31                 /* USB Plug In */
;;;32                 USBD_ENABLE_USB();
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  2190              MOVS     r1,#0x90
00002c  4308              ORRS     r0,r0,r1
00002e  4950              LDR      r1,|L4.368|
000030  6108              STR      r0,[r1,#0x10]
000032  e005              B        |L4.64|
                  |L4.52|
;;;33             }
;;;34             else
;;;35             {
;;;36                 /* USB Un-plug */
;;;37                 USBD_DISABLE_USB();
000034  484e              LDR      r0,|L4.368|
000036  6900              LDR      r0,[r0,#0x10]
000038  2180              MOVS     r1,#0x80
00003a  4388              BICS     r0,r0,r1
00003c  494c              LDR      r1,|L4.368|
00003e  6108              STR      r0,[r1,#0x10]
                  |L4.64|
;;;38             }
;;;39         }
;;;40     
;;;41         //------------------------------------------------------------------
;;;42         if (u32IntSts & USBD_INTSTS_BUS)
000040  07e0              LSLS     r0,r4,#31
000042  0fc0              LSRS     r0,r0,#31
000044  2800              CMP      r0,#0
000046  d021              BEQ      |L4.140|
;;;43         {
;;;44             /* Clear event flag */
;;;45             USBD_CLR_INT_FLAG(USBD_INTSTS_BUS);
000048  2001              MOVS     r0,#1
00004a  4949              LDR      r1,|L4.368|
00004c  6048              STR      r0,[r1,#4]
;;;46     
;;;47             if (u32State & USBD_STATE_USBRST)
00004e  4028              ANDS     r0,r0,r5
000050  2800              CMP      r0,#0
000052  d007              BEQ      |L4.100|
;;;48             {
;;;49                 /* Bus reset */
;;;50                 USBD_ENABLE_USB();
000054  4608              MOV      r0,r1
000056  6900              LDR      r0,[r0,#0x10]
000058  2190              MOVS     r1,#0x90
00005a  4308              ORRS     r0,r0,r1
00005c  4944              LDR      r1,|L4.368|
00005e  6108              STR      r0,[r1,#0x10]
;;;51                 USBD_SwReset();
000060  f7fffffe          BL       USBD_SwReset
                  |L4.100|
;;;52             }
;;;53     
;;;54             if (u32State & USBD_STATE_SUSPEND)
000064  2002              MOVS     r0,#2
000066  4028              ANDS     r0,r0,r5
000068  2800              CMP      r0,#0
00006a  d005              BEQ      |L4.120|
;;;55             {
;;;56                 /* Enable USB but disable PHY */
;;;57                 USBD_DISABLE_PHY();
00006c  4840              LDR      r0,|L4.368|
00006e  6900              LDR      r0,[r0,#0x10]
000070  2110              MOVS     r1,#0x10
000072  4388              BICS     r0,r0,r1
000074  493e              LDR      r1,|L4.368|
000076  6108              STR      r0,[r1,#0x10]
                  |L4.120|
;;;58             }
;;;59     
;;;60             if (u32State & USBD_STATE_RESUME)
000078  2004              MOVS     r0,#4
00007a  4028              ANDS     r0,r0,r5
00007c  2800              CMP      r0,#0
00007e  d005              BEQ      |L4.140|
;;;61             {
;;;62                 /* Enable USB and enable PHY */
;;;63                 USBD_ENABLE_USB();
000080  483b              LDR      r0,|L4.368|
000082  6900              LDR      r0,[r0,#0x10]
000084  2190              MOVS     r1,#0x90
000086  4308              ORRS     r0,r0,r1
000088  4939              LDR      r1,|L4.368|
00008a  6108              STR      r0,[r1,#0x10]
                  |L4.140|
;;;64             }
;;;65     
;;;66     #ifdef SUPPORT_LPM
;;;67     
;;;68             if (u32State & USBD_STATE_L1SUSPEND)
;;;69             {
;;;70                 /*
;;;71                    TODO: Implement LPM SUSPEND flag here.
;;;72                          Recommend implementing the power-saving function in main loop.
;;;73                 */
;;;74             }
;;;75     
;;;76             if (u32State & USBD_STATE_L1RESUME)
;;;77             {
;;;78                 /*
;;;79                    TODO: Implement LPM RESUME flag here.
;;;80                 */
;;;81             }
;;;82     
;;;83     #endif
;;;84     
;;;85         }
;;;86     
;;;87         if (u32IntSts & USBD_INTSTS_NEVWKIF_Msk)
00008c  2008              MOVS     r0,#8
00008e  4020              ANDS     r0,r0,r4
000090  2800              CMP      r0,#0
000092  d002              BEQ      |L4.154|
;;;88         {
;;;89             /*Clear no-event wake up interrupt */
;;;90             USBD_CLR_INT_FLAG(USBD_INTSTS_NEVWKIF_Msk);
000094  2008              MOVS     r0,#8
000096  4936              LDR      r1,|L4.368|
000098  6048              STR      r0,[r1,#4]
                  |L4.154|
;;;91             /*
;;;92                TODO: Implement the function that will be executed when device is woken by non-USB event.
;;;93             */
;;;94         }
;;;95     
;;;96         //------------------------------------------------------------------
;;;97         if (u32IntSts & USBD_INTSTS_USB)
00009a  2002              MOVS     r0,#2
00009c  4020              ANDS     r0,r0,r4
00009e  2800              CMP      r0,#0
0000a0  d065              BEQ      |L4.366|
;;;98         {
;;;99             // USB event
;;;100            if (u32IntSts & USBD_INTSTS_SETUP)
0000a2  0fe0              LSRS     r0,r4,#31
0000a4  07c0              LSLS     r0,r0,#31
0000a6  2800              CMP      r0,#0
0000a8  d011              BEQ      |L4.206|
;;;101            {
;;;102                // Setup packet
;;;103                /* Clear event flag */
;;;104                USBD_CLR_INT_FLAG(USBD_INTSTS_SETUP);
0000aa  2001              MOVS     r0,#1
0000ac  07c0              LSLS     r0,r0,#31
0000ae  4930              LDR      r1,|L4.368|
0000b0  6048              STR      r0,[r1,#4]
;;;105    
;;;106                /* Clear the data IN/OUT ready flag of control end-points */
;;;107                USBD_STOP_TRANSACTION(EP0);
0000b2  4830              LDR      r0,|L4.372|
0000b4  68c0              LDR      r0,[r0,#0xc]
0000b6  2101              MOVS     r1,#1
0000b8  4308              ORRS     r0,r0,r1
0000ba  492e              LDR      r1,|L4.372|
0000bc  60c8              STR      r0,[r1,#0xc]
;;;108                USBD_STOP_TRANSACTION(EP1);
0000be  4608              MOV      r0,r1
0000c0  69c0              LDR      r0,[r0,#0x1c]
0000c2  2101              MOVS     r1,#1
0000c4  4308              ORRS     r0,r0,r1
0000c6  492b              LDR      r1,|L4.372|
0000c8  61c8              STR      r0,[r1,#0x1c]
;;;109    
;;;110                USBD_ProcessSetupPacket();
0000ca  f7fffffe          BL       USBD_ProcessSetupPacket
                  |L4.206|
;;;111            }
;;;112    
;;;113            // EP events
;;;114            if (u32IntSts & USBD_INTSTS_EP0)
0000ce  2001              MOVS     r0,#1
0000d0  0400              LSLS     r0,r0,#16
0000d2  4020              ANDS     r0,r0,r4
0000d4  2800              CMP      r0,#0
0000d6  d005              BEQ      |L4.228|
;;;115            {
;;;116                /* Clear event flag */
;;;117                USBD_CLR_INT_FLAG(USBD_INTSTS_EP0);
0000d8  2001              MOVS     r0,#1
0000da  0400              LSLS     r0,r0,#16
0000dc  4924              LDR      r1,|L4.368|
0000de  6048              STR      r0,[r1,#4]
;;;118                // control IN
;;;119                USBD_CtrlIn();
0000e0  f7fffffe          BL       USBD_CtrlIn
                  |L4.228|
;;;120            }
;;;121    
;;;122            if (u32IntSts & USBD_INTSTS_EP1)
0000e4  2001              MOVS     r0,#1
0000e6  0440              LSLS     r0,r0,#17
0000e8  4020              ANDS     r0,r0,r4
0000ea  2800              CMP      r0,#0
0000ec  d007              BEQ      |L4.254|
;;;123            {
;;;124                /* Clear event flag */
;;;125                USBD_CLR_INT_FLAG(USBD_INTSTS_EP1);
0000ee  2001              MOVS     r0,#1
0000f0  0440              LSLS     r0,r0,#17
0000f2  491f              LDR      r1,|L4.368|
0000f4  6048              STR      r0,[r1,#4]
;;;126    
;;;127                // control OUT
;;;128                USBD_CtrlOut();
0000f6  f7fffffe          BL       USBD_CtrlOut
;;;129    					
;;;130    						Change_LED_OnOff(); // add for led control
0000fa  f7fffffe          BL       Change_LED_OnOff
                  |L4.254|
;;;131            }
;;;132    
;;;133            if (u32IntSts & USBD_INTSTS_EP2)
0000fe  2001              MOVS     r0,#1
000100  0480              LSLS     r0,r0,#18
000102  4020              ANDS     r0,r0,r4
000104  2800              CMP      r0,#0
000106  d005              BEQ      |L4.276|
;;;134            {
;;;135                /* Clear event flag */
;;;136                USBD_CLR_INT_FLAG(USBD_INTSTS_EP2);
000108  2001              MOVS     r0,#1
00010a  0480              LSLS     r0,r0,#18
00010c  4918              LDR      r1,|L4.368|
00010e  6048              STR      r0,[r1,#4]
;;;137                // Interrupt IN
;;;138                EP2_Handler();
000110  f7fffffe          BL       EP2_Handler
                  |L4.276|
;;;139            }
;;;140    
;;;141            if (u32IntSts & USBD_INTSTS_EP3)
000114  2001              MOVS     r0,#1
000116  04c0              LSLS     r0,r0,#19
000118  4020              ANDS     r0,r0,r4
00011a  2800              CMP      r0,#0
00011c  d003              BEQ      |L4.294|
;;;142            {
;;;143                /* Clear event flag */
;;;144                USBD_CLR_INT_FLAG(USBD_INTSTS_EP3);
00011e  2001              MOVS     r0,#1
000120  04c0              LSLS     r0,r0,#19
000122  4913              LDR      r1,|L4.368|
000124  6048              STR      r0,[r1,#4]
                  |L4.294|
;;;145            }
;;;146    
;;;147            if (u32IntSts & USBD_INTSTS_EP4)
000126  2001              MOVS     r0,#1
000128  0500              LSLS     r0,r0,#20
00012a  4020              ANDS     r0,r0,r4
00012c  2800              CMP      r0,#0
00012e  d003              BEQ      |L4.312|
;;;148            {
;;;149                /* Clear event flag */
;;;150                USBD_CLR_INT_FLAG(USBD_INTSTS_EP4);
000130  2001              MOVS     r0,#1
000132  0500              LSLS     r0,r0,#20
000134  490e              LDR      r1,|L4.368|
000136  6048              STR      r0,[r1,#4]
                  |L4.312|
;;;151            }
;;;152    
;;;153            if (u32IntSts & USBD_INTSTS_EP5)
000138  2001              MOVS     r0,#1
00013a  0540              LSLS     r0,r0,#21
00013c  4020              ANDS     r0,r0,r4
00013e  2800              CMP      r0,#0
000140  d003              BEQ      |L4.330|
;;;154            {
;;;155                /* Clear event flag */
;;;156                USBD_CLR_INT_FLAG(USBD_INTSTS_EP5);
000142  2001              MOVS     r0,#1
000144  0540              LSLS     r0,r0,#21
000146  490a              LDR      r1,|L4.368|
000148  6048              STR      r0,[r1,#4]
                  |L4.330|
;;;157            }
;;;158    
;;;159            if (u32IntSts & USBD_INTSTS_EP6)
00014a  2001              MOVS     r0,#1
00014c  0580              LSLS     r0,r0,#22
00014e  4020              ANDS     r0,r0,r4
000150  2800              CMP      r0,#0
000152  d003              BEQ      |L4.348|
;;;160            {
;;;161                /* Clear event flag */
;;;162                USBD_CLR_INT_FLAG(USBD_INTSTS_EP6);
000154  2001              MOVS     r0,#1
000156  0580              LSLS     r0,r0,#22
000158  4905              LDR      r1,|L4.368|
00015a  6048              STR      r0,[r1,#4]
                  |L4.348|
;;;163            }
;;;164    
;;;165            if (u32IntSts & USBD_INTSTS_EP7)
00015c  2001              MOVS     r0,#1
00015e  05c0              LSLS     r0,r0,#23
000160  4020              ANDS     r0,r0,r4
000162  2800              CMP      r0,#0
000164  d003              BEQ      |L4.366|
;;;166            {
;;;167                /* Clear event flag */
;;;168                USBD_CLR_INT_FLAG(USBD_INTSTS_EP7);
000166  2001              MOVS     r0,#1
000168  05c0              LSLS     r0,r0,#23
00016a  4901              LDR      r1,|L4.368|
00016c  6048              STR      r0,[r1,#4]
                  |L4.366|
;;;169            }
;;;170        }
;;;171    }
00016e  bd70              POP      {r4-r6,pc}
;;;172    
                          ENDP

                  |L4.368|
                          DCD      0x40060000
                  |L4.372|
                          DCD      0x40060500

                          AREA ||i.USBD_SetStall||, CODE, READONLY, ALIGN=2

                  USBD_SetStall PROC
;;;598      */
;;;599    static __INLINE void USBD_SetStall(uint8_t epnum)
000000  b530              PUSH     {r4,r5,lr}
;;;600    {
000002  4603              MOV      r3,r0
;;;601        uint32_t u32CfgAddr;
;;;602        uint32_t u32Cfg;
;;;603        int i;
;;;604    
;;;605        for (i = 0; i < USBD_MAX_EP; i++) {
000004  2100              MOVS     r1,#0
000006  e010              B        |L5.42|
                  |L5.8|
;;;606            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
000008  010c              LSLS     r4,r1,#4
00000a  4d0a              LDR      r5,|L5.52|
00000c  1960              ADDS     r0,r4,r5
;;;607            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
00000e  6802              LDR      r2,[r0,#0]
;;;608    
;;;609            if ((u32Cfg & 0xf) == epnum) {
000010  0714              LSLS     r4,r2,#28
000012  0f24              LSRS     r4,r4,#28
000014  429c              CMP      r4,r3
000016  d107              BNE      |L5.40|
;;;610                u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
000018  010c              LSLS     r4,r1,#4
00001a  1d2d              ADDS     r5,r5,#4
00001c  1960              ADDS     r0,r4,r5
;;;611                u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
00001e  6802              LDR      r2,[r0,#0]
;;;612    
;;;613                *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
000020  2402              MOVS     r4,#2
000022  4314              ORRS     r4,r4,r2
000024  6004              STR      r4,[r0,#0]
;;;614                break;
000026  e002              B        |L5.46|
                  |L5.40|
000028  1c49              ADDS     r1,r1,#1              ;605
                  |L5.42|
00002a  2908              CMP      r1,#8                 ;605
00002c  dbec              BLT      |L5.8|
                  |L5.46|
00002e  bf00              NOP      
;;;615            }
;;;616        }
;;;617    }
000030  bd30              POP      {r4,r5,pc}
;;;618    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40060508

                          AREA ||.data||, DATA, ALIGN=0

                  LED_Status
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "hid_kb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_hid_kb_c_462d5dd0____REV16|
#line 388 ".\\CMSIS\\cmsis_armcc.h"
|__asm___8_hid_kb_c_462d5dd0____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_hid_kb_c_462d5dd0____REVSH|
#line 402
|__asm___8_hid_kb_c_462d5dd0____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hid_kb.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\hid_kb.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\hid_kb.crf hid_kb.c]
                          THUMB

                          AREA ||i.EP2_Handler||, CODE, READONLY, ALIGN=2

                  EP2_Handler PROC
;;;178    
;;;179    void EP2_Handler(void)  /* Interrupt IN handler */
000000  2001              MOVS     r0,#1
;;;180    {
;;;181        g_u8EP2Ready = 1;
000002  4901              LDR      r1,|L1.8|
000004  7008              STRB     r0,[r1,#0]
;;;182    }
000006  4770              BX       lr
;;;183    
                          ENDP

                  |L1.8|
                          DCD      g_u8EP2Ready

                          AREA ||i.HID_ClassRequest||, CODE, READONLY, ALIGN=2

                  HID_ClassRequest PROC
;;;214    
;;;215    void HID_ClassRequest(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;216    {
;;;217        uint8_t au8Buf[8];
;;;218    
;;;219        USBD_GetSetupPacket(au8Buf);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       USBD_GetSetupPacket
;;;220    
;;;221        if (au8Buf[0] & 0x80)   /* request data transfer direction */
000008  4668              MOV      r0,sp
00000a  7800              LDRB     r0,[r0,#0]
00000c  2180              MOVS     r1,#0x80
00000e  4008              ANDS     r0,r0,r1
000010  2800              CMP      r0,#0
000012  d012              BEQ      |L2.58|
;;;222        {
;;;223            // Device to host
;;;224            switch (au8Buf[1])
000014  4668              MOV      r0,sp
000016  7840              LDRB     r0,[r0,#1]
000018  2801              CMP      r0,#1
00001a  d004              BEQ      |L2.38|
00001c  2802              CMP      r0,#2
00001e  d003              BEQ      |L2.40|
000020  2803              CMP      r0,#3
000022  d002              BEQ      |L2.42|
;;;225            {
;;;226            case GET_REPORT:
000024  bf00              NOP      
                  |L2.38|
;;;227    
;;;228            //             {
;;;229            //                 break;
;;;230            //             }
;;;231            case GET_IDLE:
000026  bf00              NOP      
                  |L2.40|
;;;232    
;;;233            //             {
;;;234            //                 break;
;;;235            //             }
;;;236            case GET_PROTOCOL:
000028  bf00              NOP      
                  |L2.42|
;;;237    
;;;238            //            {
;;;239            //                break;
;;;240            //            }
;;;241            default:
;;;242            {
;;;243                /* Setup error, stall the device */
;;;244                USBD_SetStall(EP0);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       USBD_SetStall
;;;245                USBD_SetStall(EP1);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       USBD_SetStall
;;;246                break;
000036  bf00              NOP      
000038  e03b              B        |L2.178|
                  |L2.58|
;;;247            }
;;;248            }
;;;249        }
;;;250        else
;;;251        {
;;;252            // Host to device
;;;253            switch (au8Buf[1])
00003a  4668              MOV      r0,sp
00003c  7840              LDRB     r0,[r0,#1]
00003e  2809              CMP      r0,#9
000040  d004              BEQ      |L2.76|
000042  280a              CMP      r0,#0xa
000044  d01b              BEQ      |L2.126|
000046  280b              CMP      r0,#0xb
000048  d12b              BNE      |L2.162|
00004a  e021              B        |L2.144|
                  |L2.76|
;;;254            {
;;;255            case SET_REPORT:
;;;256            {
;;;257                if (au8Buf[3] == 2)
00004c  4668              MOV      r0,sp
00004e  78c0              LDRB     r0,[r0,#3]
000050  2802              CMP      r0,#2
000052  d113              BNE      |L2.124|
;;;258                {
;;;259    								USBD_PrepareCtrlOut((uint8_t *)&LED_Status[0], 1);
000054  2101              MOVS     r1,#1
000056  4817              LDR      r0,|L2.180|
000058  f7fffffe          BL       USBD_PrepareCtrlOut
;;;260    							
;;;261                    /* Request Type = Output */
;;;262                    USBD_SET_DATA1(EP1);
00005c  4816              LDR      r0,|L2.184|
00005e  6980              LDR      r0,[r0,#0x18]
000060  2180              MOVS     r1,#0x80
000062  4308              ORRS     r0,r0,r1
000064  4914              LDR      r1,|L2.184|
000066  6188              STR      r0,[r1,#0x18]
;;;263                    USBD_SET_PAYLOAD_LEN(EP1, au8Buf[6]);
000068  4668              MOV      r0,sp
00006a  7980              LDRB     r0,[r0,#6]
00006c  6148              STR      r0,[r1,#0x14]
;;;264    
;;;265                    /* Status stage */
;;;266                    USBD_PrepareCtrlIn(0, 0);
00006e  2100              MOVS     r1,#0
000070  4608              MOV      r0,r1
000072  f7fffffe          BL       USBD_PrepareCtrlIn
;;;267    							
;;;268    								SetReport_flag = 1; //Set SetReport_flag
000076  2001              MOVS     r0,#1
000078  4910              LDR      r1,|L2.188|
00007a  7008              STRB     r0,[r1,#0]
                  |L2.124|
;;;269                }
;;;270    
;;;271                break;
00007c  e018              B        |L2.176|
                  |L2.126|
;;;272            }
;;;273    
;;;274            case SET_IDLE:
;;;275            {
;;;276                /* Status stage */
;;;277                USBD_SET_DATA1(EP0);
00007e  480e              LDR      r0,|L2.184|
000080  6880              LDR      r0,[r0,#8]
000082  2180              MOVS     r1,#0x80
000084  4308              ORRS     r0,r0,r1
000086  490c              LDR      r1,|L2.184|
000088  6088              STR      r0,[r1,#8]
;;;278                USBD_SET_PAYLOAD_LEN(EP0, 0);
00008a  2000              MOVS     r0,#0
00008c  6048              STR      r0,[r1,#4]
;;;279                break;
00008e  e00f              B        |L2.176|
                  |L2.144|
;;;280            }
;;;281    
;;;282            case SET_PROTOCOL:
;;;283            {
;;;284                USBD_SET_DATA1(EP0);
000090  4809              LDR      r0,|L2.184|
000092  6880              LDR      r0,[r0,#8]
000094  2180              MOVS     r1,#0x80
000096  4308              ORRS     r0,r0,r1
000098  4907              LDR      r1,|L2.184|
00009a  6088              STR      r0,[r1,#8]
;;;285                USBD_SET_PAYLOAD_LEN(EP0, 0);
00009c  2000              MOVS     r0,#0
00009e  6048              STR      r0,[r1,#4]
;;;286                break;
0000a0  e006              B        |L2.176|
                  |L2.162|
;;;287            }
;;;288    
;;;289            default:
;;;290            {
;;;291                // Stall
;;;292                /* Setup error, stall the device */
;;;293                USBD_SetStall(EP0);
0000a2  2000              MOVS     r0,#0
0000a4  f7fffffe          BL       USBD_SetStall
;;;294                USBD_SetStall(EP1);
0000a8  2001              MOVS     r0,#1
0000aa  f7fffffe          BL       USBD_SetStall
;;;295                break;
0000ae  bf00              NOP      
                  |L2.176|
0000b0  bf00              NOP                            ;271
                  |L2.178|
;;;296            }
;;;297            }
;;;298        }
;;;299    }
0000b2  bd1c              POP      {r2-r4,pc}
;;;300    
                          ENDP

                  |L2.180|
                          DCD      LED_Status
                  |L2.184|
                          DCD      0x40060500
                  |L2.188|
                          DCD      SetReport_flag

                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;189      */
;;;190    void HID_Init(void)
000000  2000              MOVS     r0,#0
;;;191    {
;;;192        /* Init setup packet buffer */
;;;193        /* Buffer range for setup packet -> [0 ~ 0x7] */
;;;194        USBD->STBUFSEG = SETUP_BUF_BASE;
000002  4909              LDR      r1,|L3.40|
000004  6188              STR      r0,[r1,#0x18]
;;;195    
;;;196        /*****************************************************/
;;;197        /* EP0 ==> control IN endpoint, address 0 */
;;;198        USBD_CONFIG_EP(EP0, USBD_CFG_CSTALL | USBD_CFG_EPMODE_IN | 0);
000006  2009              MOVS     r0,#9
000008  0180              LSLS     r0,r0,#6
00000a  4908              LDR      r1,|L3.44|
00000c  6088              STR      r0,[r1,#8]
;;;199        /* Buffer range for EP0 */
;;;200        USBD_SET_EP_BUF_ADDR(EP0, EP0_BUF_BASE);
00000e  2008              MOVS     r0,#8
000010  6008              STR      r0,[r1,#0]
;;;201    
;;;202        /* EP1 ==> control OUT endpoint, address 0 */
;;;203        USBD_CONFIG_EP(EP1, USBD_CFG_CSTALL | USBD_CFG_EPMODE_OUT | 0);
000012  2011              MOVS     r0,#0x11
000014  0140              LSLS     r0,r0,#5
000016  6188              STR      r0,[r1,#0x18]
;;;204        /* Buffer range for EP1 */
;;;205        USBD_SET_EP_BUF_ADDR(EP1, EP1_BUF_BASE);
000018  2008              MOVS     r0,#8
00001a  6108              STR      r0,[r1,#0x10]
;;;206    
;;;207        /*****************************************************/
;;;208        /* EP2 ==> Interrupt IN endpoint, address 1 */
;;;209        USBD_CONFIG_EP(EP2, USBD_CFG_EPMODE_IN | INT_IN_EP_NUM);
00001c  2041              MOVS     r0,#0x41
00001e  6288              STR      r0,[r1,#0x28]
;;;210        /* Buffer range for EP2 */
;;;211        USBD_SET_EP_BUF_ADDR(EP2, EP2_BUF_BASE);
000020  2010              MOVS     r0,#0x10
000022  6208              STR      r0,[r1,#0x20]
;;;212    
;;;213    }
000024  4770              BX       lr
;;;214    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40060000
                  |L3.44|
                          DCD      0x40060500

                          AREA ||i.USBD_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_IRQHandler PROC
;;;18     
;;;19     void USBD_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;20     {
;;;21         uint32_t u32IntSts = USBD_GET_INT_FLAG();
000002  485f              LDR      r0,|L4.384|
000004  6844              LDR      r4,[r0,#4]
;;;22         uint32_t u32State = USBD_GET_BUS_STATE();
000006  6900              LDR      r0,[r0,#0x10]
000008  0705              LSLS     r5,r0,#28
00000a  0f2d              LSRS     r5,r5,#28
;;;23     
;;;24         //------------------------------------------------------------------
;;;25         if (u32IntSts & USBD_INTSTS_FLDET)
00000c  2004              MOVS     r0,#4
00000e  4020              ANDS     r0,r0,r4
000010  2800              CMP      r0,#0
000012  d015              BEQ      |L4.64|
;;;26         {
;;;27             // Floating detect
;;;28             USBD_CLR_INT_FLAG(USBD_INTSTS_FLDET);
000014  2004              MOVS     r0,#4
000016  495a              LDR      r1,|L4.384|
000018  6048              STR      r0,[r1,#4]
;;;29     
;;;30             if (USBD_IS_ATTACHED())
00001a  4608              MOV      r0,r1
00001c  6940              LDR      r0,[r0,#0x14]
00001e  07c0              LSLS     r0,r0,#31
000020  0fc0              LSRS     r0,r0,#31
000022  2800              CMP      r0,#0
000024  d006              BEQ      |L4.52|
;;;31             {
;;;32                 /* USB Plug In */
;;;33                 USBD_ENABLE_USB();
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  2190              MOVS     r1,#0x90
00002c  4308              ORRS     r0,r0,r1
00002e  4954              LDR      r1,|L4.384|
000030  6108              STR      r0,[r1,#0x10]
000032  e005              B        |L4.64|
                  |L4.52|
;;;34             }
;;;35             else
;;;36             {
;;;37                 /* USB Un-plug */
;;;38                 USBD_DISABLE_USB();
000034  4852              LDR      r0,|L4.384|
000036  6900              LDR      r0,[r0,#0x10]
000038  2180              MOVS     r1,#0x80
00003a  4388              BICS     r0,r0,r1
00003c  4950              LDR      r1,|L4.384|
00003e  6108              STR      r0,[r1,#0x10]
                  |L4.64|
;;;39             }
;;;40         }
;;;41     
;;;42         //------------------------------------------------------------------
;;;43         if (u32IntSts & USBD_INTSTS_BUS)
000040  07e0              LSLS     r0,r4,#31
000042  0fc0              LSRS     r0,r0,#31
000044  2800              CMP      r0,#0
000046  d021              BEQ      |L4.140|
;;;44         {
;;;45             /* Clear event flag */
;;;46             USBD_CLR_INT_FLAG(USBD_INTSTS_BUS);
000048  2001              MOVS     r0,#1
00004a  494d              LDR      r1,|L4.384|
00004c  6048              STR      r0,[r1,#4]
;;;47     
;;;48             if (u32State & USBD_STATE_USBRST)
00004e  4028              ANDS     r0,r0,r5
000050  2800              CMP      r0,#0
000052  d007              BEQ      |L4.100|
;;;49             {
;;;50                 /* Bus reset */
;;;51                 USBD_ENABLE_USB();
000054  4608              MOV      r0,r1
000056  6900              LDR      r0,[r0,#0x10]
000058  2190              MOVS     r1,#0x90
00005a  4308              ORRS     r0,r0,r1
00005c  4948              LDR      r1,|L4.384|
00005e  6108              STR      r0,[r1,#0x10]
;;;52                 USBD_SwReset();
000060  f7fffffe          BL       USBD_SwReset
                  |L4.100|
;;;53             }
;;;54     
;;;55             if (u32State & USBD_STATE_SUSPEND)
000064  2002              MOVS     r0,#2
000066  4028              ANDS     r0,r0,r5
000068  2800              CMP      r0,#0
00006a  d005              BEQ      |L4.120|
;;;56             {
;;;57                 /* Enable USB but disable PHY */
;;;58                 USBD_DISABLE_PHY();
00006c  4844              LDR      r0,|L4.384|
00006e  6900              LDR      r0,[r0,#0x10]
000070  2110              MOVS     r1,#0x10
000072  4388              BICS     r0,r0,r1
000074  4942              LDR      r1,|L4.384|
000076  6108              STR      r0,[r1,#0x10]
                  |L4.120|
;;;59             }
;;;60     
;;;61             if (u32State & USBD_STATE_RESUME)
000078  2004              MOVS     r0,#4
00007a  4028              ANDS     r0,r0,r5
00007c  2800              CMP      r0,#0
00007e  d005              BEQ      |L4.140|
;;;62             {
;;;63                 /* Enable USB and enable PHY */
;;;64                 USBD_ENABLE_USB();
000080  483f              LDR      r0,|L4.384|
000082  6900              LDR      r0,[r0,#0x10]
000084  2190              MOVS     r1,#0x90
000086  4308              ORRS     r0,r0,r1
000088  493d              LDR      r1,|L4.384|
00008a  6108              STR      r0,[r1,#0x10]
                  |L4.140|
;;;65             }
;;;66     
;;;67     #ifdef SUPPORT_LPM
;;;68     
;;;69             if (u32State & USBD_STATE_L1SUSPEND)
;;;70             {
;;;71                 /*
;;;72                    TODO: Implement LPM SUSPEND flag here.
;;;73                          Recommend implementing the power-saving function in main loop.
;;;74                 */
;;;75             }
;;;76     
;;;77             if (u32State & USBD_STATE_L1RESUME)
;;;78             {
;;;79                 /*
;;;80                    TODO: Implement LPM RESUME flag here.
;;;81                 */
;;;82             }
;;;83     
;;;84     #endif
;;;85     
;;;86         }
;;;87     
;;;88         if (u32IntSts & USBD_INTSTS_NEVWKIF_Msk)
00008c  2008              MOVS     r0,#8
00008e  4020              ANDS     r0,r0,r4
000090  2800              CMP      r0,#0
000092  d002              BEQ      |L4.154|
;;;89         {
;;;90             /*Clear no-event wake up interrupt */
;;;91             USBD_CLR_INT_FLAG(USBD_INTSTS_NEVWKIF_Msk);
000094  2008              MOVS     r0,#8
000096  493a              LDR      r1,|L4.384|
000098  6048              STR      r0,[r1,#4]
                  |L4.154|
;;;92             /*
;;;93                TODO: Implement the function that will be executed when device is woken by non-USB event.
;;;94             */
;;;95         }
;;;96     
;;;97         //------------------------------------------------------------------
;;;98         if (u32IntSts & USBD_INTSTS_USB)
00009a  2002              MOVS     r0,#2
00009c  4020              ANDS     r0,r0,r4
00009e  2800              CMP      r0,#0
0000a0  d06c              BEQ      |L4.380|
;;;99         {
;;;100            // USB event
;;;101            if (u32IntSts & USBD_INTSTS_SETUP)
0000a2  0fe0              LSRS     r0,r4,#31
0000a4  07c0              LSLS     r0,r0,#31
0000a6  2800              CMP      r0,#0
0000a8  d011              BEQ      |L4.206|
;;;102            {
;;;103                // Setup packet
;;;104                /* Clear event flag */
;;;105                USBD_CLR_INT_FLAG(USBD_INTSTS_SETUP);
0000aa  2001              MOVS     r0,#1
0000ac  07c0              LSLS     r0,r0,#31
0000ae  4934              LDR      r1,|L4.384|
0000b0  6048              STR      r0,[r1,#4]
;;;106    
;;;107                /* Clear the data IN/OUT ready flag of control end-points */
;;;108                USBD_STOP_TRANSACTION(EP0);
0000b2  4834              LDR      r0,|L4.388|
0000b4  68c0              LDR      r0,[r0,#0xc]
0000b6  2101              MOVS     r1,#1
0000b8  4308              ORRS     r0,r0,r1
0000ba  4932              LDR      r1,|L4.388|
0000bc  60c8              STR      r0,[r1,#0xc]
;;;109                USBD_STOP_TRANSACTION(EP1);
0000be  4608              MOV      r0,r1
0000c0  69c0              LDR      r0,[r0,#0x1c]
0000c2  2101              MOVS     r1,#1
0000c4  4308              ORRS     r0,r0,r1
0000c6  492f              LDR      r1,|L4.388|
0000c8  61c8              STR      r0,[r1,#0x1c]
;;;110    
;;;111                USBD_ProcessSetupPacket();
0000ca  f7fffffe          BL       USBD_ProcessSetupPacket
                  |L4.206|
;;;112            }
;;;113    
;;;114            // EP events
;;;115            if (u32IntSts & USBD_INTSTS_EP0)
0000ce  2001              MOVS     r0,#1
0000d0  0400              LSLS     r0,r0,#16
0000d2  4020              ANDS     r0,r0,r4
0000d4  2800              CMP      r0,#0
0000d6  d005              BEQ      |L4.228|
;;;116            {
;;;117                /* Clear event flag */
;;;118                USBD_CLR_INT_FLAG(USBD_INTSTS_EP0);
0000d8  2001              MOVS     r0,#1
0000da  0400              LSLS     r0,r0,#16
0000dc  4928              LDR      r1,|L4.384|
0000de  6048              STR      r0,[r1,#4]
;;;119                // control IN
;;;120                USBD_CtrlIn();
0000e0  f7fffffe          BL       USBD_CtrlIn
                  |L4.228|
;;;121            }
;;;122    
;;;123            if (u32IntSts & USBD_INTSTS_EP1)
0000e4  2001              MOVS     r0,#1
0000e6  0440              LSLS     r0,r0,#17
0000e8  4020              ANDS     r0,r0,r4
0000ea  2800              CMP      r0,#0
0000ec  d00e              BEQ      |L4.268|
;;;124            {
;;;125                /* Clear event flag */
;;;126                USBD_CLR_INT_FLAG(USBD_INTSTS_EP1);
0000ee  2001              MOVS     r0,#1
0000f0  0440              LSLS     r0,r0,#17
0000f2  4923              LDR      r1,|L4.384|
0000f4  6048              STR      r0,[r1,#4]
;;;127    
;;;128                // control OUT
;;;129                USBD_CtrlOut();
0000f6  f7fffffe          BL       USBD_CtrlOut
;;;130    					
;;;131    						if(SetReport_flag == 1)
0000fa  4823              LDR      r0,|L4.392|
0000fc  7800              LDRB     r0,[r0,#0]  ; SetReport_flag
0000fe  2801              CMP      r0,#1
000100  d104              BNE      |L4.268|
;;;132    						{
;;;133    								SetReport_flag = 0;
000102  2000              MOVS     r0,#0
000104  4920              LDR      r1,|L4.392|
000106  7008              STRB     r0,[r1,#0]
;;;134    								Change_LED_OnOff(); // add for led control
000108  f7fffffe          BL       Change_LED_OnOff
                  |L4.268|
;;;135    						}
;;;136    						
;;;137            }
;;;138    
;;;139            if (u32IntSts & USBD_INTSTS_EP2)
00010c  2001              MOVS     r0,#1
00010e  0480              LSLS     r0,r0,#18
000110  4020              ANDS     r0,r0,r4
000112  2800              CMP      r0,#0
000114  d005              BEQ      |L4.290|
;;;140            {
;;;141                /* Clear event flag */
;;;142                USBD_CLR_INT_FLAG(USBD_INTSTS_EP2);
000116  2001              MOVS     r0,#1
000118  0480              LSLS     r0,r0,#18
00011a  4919              LDR      r1,|L4.384|
00011c  6048              STR      r0,[r1,#4]
;;;143                // Interrupt IN
;;;144                EP2_Handler();
00011e  f7fffffe          BL       EP2_Handler
                  |L4.290|
;;;145            }
;;;146    
;;;147            if (u32IntSts & USBD_INTSTS_EP3)
000122  2001              MOVS     r0,#1
000124  04c0              LSLS     r0,r0,#19
000126  4020              ANDS     r0,r0,r4
000128  2800              CMP      r0,#0
00012a  d003              BEQ      |L4.308|
;;;148            {
;;;149                /* Clear event flag */
;;;150                USBD_CLR_INT_FLAG(USBD_INTSTS_EP3);
00012c  2001              MOVS     r0,#1
00012e  04c0              LSLS     r0,r0,#19
000130  4913              LDR      r1,|L4.384|
000132  6048              STR      r0,[r1,#4]
                  |L4.308|
;;;151            }
;;;152    
;;;153            if (u32IntSts & USBD_INTSTS_EP4)
000134  2001              MOVS     r0,#1
000136  0500              LSLS     r0,r0,#20
000138  4020              ANDS     r0,r0,r4
00013a  2800              CMP      r0,#0
00013c  d003              BEQ      |L4.326|
;;;154            {
;;;155                /* Clear event flag */
;;;156                USBD_CLR_INT_FLAG(USBD_INTSTS_EP4);
00013e  2001              MOVS     r0,#1
000140  0500              LSLS     r0,r0,#20
000142  490f              LDR      r1,|L4.384|
000144  6048              STR      r0,[r1,#4]
                  |L4.326|
;;;157            }
;;;158    
;;;159            if (u32IntSts & USBD_INTSTS_EP5)
000146  2001              MOVS     r0,#1
000148  0540              LSLS     r0,r0,#21
00014a  4020              ANDS     r0,r0,r4
00014c  2800              CMP      r0,#0
00014e  d003              BEQ      |L4.344|
;;;160            {
;;;161                /* Clear event flag */
;;;162                USBD_CLR_INT_FLAG(USBD_INTSTS_EP5);
000150  2001              MOVS     r0,#1
000152  0540              LSLS     r0,r0,#21
000154  490a              LDR      r1,|L4.384|
000156  6048              STR      r0,[r1,#4]
                  |L4.344|
;;;163            }
;;;164    
;;;165            if (u32IntSts & USBD_INTSTS_EP6)
000158  2001              MOVS     r0,#1
00015a  0580              LSLS     r0,r0,#22
00015c  4020              ANDS     r0,r0,r4
00015e  2800              CMP      r0,#0
000160  d003              BEQ      |L4.362|
;;;166            {
;;;167                /* Clear event flag */
;;;168                USBD_CLR_INT_FLAG(USBD_INTSTS_EP6);
000162  2001              MOVS     r0,#1
000164  0580              LSLS     r0,r0,#22
000166  4906              LDR      r1,|L4.384|
000168  6048              STR      r0,[r1,#4]
                  |L4.362|
;;;169            }
;;;170    
;;;171            if (u32IntSts & USBD_INTSTS_EP7)
00016a  2001              MOVS     r0,#1
00016c  05c0              LSLS     r0,r0,#23
00016e  4020              ANDS     r0,r0,r4
000170  2800              CMP      r0,#0
000172  d003              BEQ      |L4.380|
;;;172            {
;;;173                /* Clear event flag */
;;;174                USBD_CLR_INT_FLAG(USBD_INTSTS_EP7);
000174  2001              MOVS     r0,#1
000176  05c0              LSLS     r0,r0,#23
000178  4901              LDR      r1,|L4.384|
00017a  6048              STR      r0,[r1,#4]
                  |L4.380|
;;;175            }
;;;176        }
;;;177    }
00017c  bd70              POP      {r4-r6,pc}
;;;178    
                          ENDP

00017e  0000              DCW      0x0000
                  |L4.384|
                          DCD      0x40060000
                  |L4.388|
                          DCD      0x40060500
                  |L4.392|
                          DCD      SetReport_flag

                          AREA ||i.USBD_SetStall||, CODE, READONLY, ALIGN=2

                  USBD_SetStall PROC
;;;598      */
;;;599    static __INLINE void USBD_SetStall(uint8_t epnum)
000000  b530              PUSH     {r4,r5,lr}
;;;600    {
000002  4603              MOV      r3,r0
;;;601        uint32_t u32CfgAddr;
;;;602        uint32_t u32Cfg;
;;;603        int i;
;;;604    
;;;605        for (i = 0; i < USBD_MAX_EP; i++) {
000004  2100              MOVS     r1,#0
000006  e010              B        |L5.42|
                  |L5.8|
;;;606            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
000008  010c              LSLS     r4,r1,#4
00000a  4d0a              LDR      r5,|L5.52|
00000c  1960              ADDS     r0,r4,r5
;;;607            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
00000e  6802              LDR      r2,[r0,#0]
;;;608    
;;;609            if ((u32Cfg & 0xf) == epnum) {
000010  0714              LSLS     r4,r2,#28
000012  0f24              LSRS     r4,r4,#28
000014  429c              CMP      r4,r3
000016  d107              BNE      |L5.40|
;;;610                u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
000018  010c              LSLS     r4,r1,#4
00001a  1d2d              ADDS     r5,r5,#4
00001c  1960              ADDS     r0,r4,r5
;;;611                u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
00001e  6802              LDR      r2,[r0,#0]
;;;612    
;;;613                *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
000020  2402              MOVS     r4,#2
000022  4314              ORRS     r4,r4,r2
000024  6004              STR      r4,[r0,#0]
;;;614                break;
000026  e002              B        |L5.46|
                  |L5.40|
000028  1c49              ADDS     r1,r1,#1              ;605
                  |L5.42|
00002a  2908              CMP      r1,#8                 ;605
00002c  dbec              BLT      |L5.8|
                  |L5.46|
00002e  bf00              NOP      
;;;615            }
;;;616        }
;;;617    }
000030  bd30              POP      {r4,r5,pc}
;;;618    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40060508

                          AREA ||.data||, DATA, ALIGN=0

                  SetReport_flag
000000  00                DCB      0x00
                  LED_Status
000001  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "hid_kb.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_hid_kb_c_f1827c1d____REV16|
#line 388 ".\\CMSIS\\cmsis_armcc.h"
|__asm___8_hid_kb_c_f1827c1d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_hid_kb_c_f1827c1d____REVSH|
#line 402
|__asm___8_hid_kb_c_f1827c1d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

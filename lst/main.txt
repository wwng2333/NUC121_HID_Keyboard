; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\main.crf main.c]
                          THUMB

                          AREA ||i.HID_UpdateKbData||, CODE, READONLY, ALIGN=2

                  HID_UpdateKbData PROC
;;;73     
;;;74     void HID_UpdateKbData(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;75     {
;;;76         int32_t i;
;;;77         uint8_t *pu8Buf;
;;;78         uint32_t u32Key = 0xF;
000002  210f              MOVS     r1,#0xf
;;;79         static uint32_t u32PreKey;
;;;80     		//uint8_t key_numeral[10] = {0x27, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26};
;;;81     		uint8_t key_numeral[10] = {0x62, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61};
000004  a549              ADR      r5,|L1.300|
000006  cd38              LDM      r5,{r3-r5}
000008  4668              MOV      r0,sp
00000a  c038              STM      r0!,{r3-r5}
;;;82     
;;;83         if (g_u8EP2Ready)
00000c  4b4a              LDR      r3,|L1.312|
00000e  781b              LDRB     r3,[r3,#0]  ; g_u8EP2Ready
000010  2b00              CMP      r3,#0
000012  d075              BEQ      |L1.256|
;;;84         {
;;;85             pu8Buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP2));
000014  4b49              LDR      r3,|L1.316|
000016  6a1b              LDR      r3,[r3,#0x20]
000018  4c49              LDR      r4,|L1.320|
00001a  191a              ADDS     r2,r3,r4
;;;86     
;;;87             /* If PA.10 = 0, just report it is key 'a' and 'b' */
;;;88             //u32Key = (PA->PIN & (1 << 10)) ? 0 : 1;
;;;89     
;;;90     				u32Key = 0;
00001c  2100              MOVS     r1,#0
;;;91     				if(!PD2)	 u32Key = key_numeral[1];
00001e  4b49              LDR      r3,|L1.324|
000020  689b              LDR      r3,[r3,#8]
000022  2b00              CMP      r3,#0
000024  d101              BNE      |L1.42|
000026  466b              MOV      r3,sp
000028  7859              LDRB     r1,[r3,#1]
                  |L1.42|
;;;92     				if(!PD1)	 u32Key = key_numeral[2];
00002a  4b46              LDR      r3,|L1.324|
00002c  685b              LDR      r3,[r3,#4]
00002e  2b00              CMP      r3,#0
000030  d101              BNE      |L1.54|
000032  466b              MOV      r3,sp
000034  7899              LDRB     r1,[r3,#2]
                  |L1.54|
;;;93     				if(!PC10)	 u32Key = key_numeral[3];
000036  4b43              LDR      r3,|L1.324|
000038  3b40              SUBS     r3,r3,#0x40
00003a  6a9b              LDR      r3,[r3,#0x28]
00003c  2b00              CMP      r3,#0
00003e  d101              BNE      |L1.68|
000040  466b              MOV      r3,sp
000042  78d9              LDRB     r1,[r3,#3]
                  |L1.68|
;;;94     				if(!PB14)	 u32Key = key_numeral[4];
000044  4b3f              LDR      r3,|L1.324|
000046  3b80              SUBS     r3,r3,#0x80
000048  6b9b              LDR      r3,[r3,#0x38]
00004a  2b00              CMP      r3,#0
00004c  d101              BNE      |L1.82|
00004e  466b              MOV      r3,sp
000050  7919              LDRB     r1,[r3,#4]
                  |L1.82|
;;;95     				if(!PD3)	 u32Key = key_numeral[5];
000052  4b3c              LDR      r3,|L1.324|
000054  68db              LDR      r3,[r3,#0xc]
000056  2b00              CMP      r3,#0
000058  d101              BNE      |L1.94|
00005a  466b              MOV      r3,sp
00005c  7959              LDRB     r1,[r3,#5]
                  |L1.94|
;;;96     				if(!PC9)	 u32Key = key_numeral[6];
00005e  4b39              LDR      r3,|L1.324|
000060  3b40              SUBS     r3,r3,#0x40
000062  6a5b              LDR      r3,[r3,#0x24]
000064  2b00              CMP      r3,#0
000066  d101              BNE      |L1.108|
000068  466b              MOV      r3,sp
00006a  7999              LDRB     r1,[r3,#6]
                  |L1.108|
;;;97     				if(!PA11)	 u32Key = key_numeral[7];
00006c  4b35              LDR      r3,|L1.324|
00006e  3bc0              SUBS     r3,r3,#0xc0
000070  6adb              LDR      r3,[r3,#0x2c]
000072  2b00              CMP      r3,#0
000074  d101              BNE      |L1.122|
000076  466b              MOV      r3,sp
000078  79d9              LDRB     r1,[r3,#7]
                  |L1.122|
;;;98     				if(!PB5)	 u32Key = key_numeral[8];
00007a  4b32              LDR      r3,|L1.324|
00007c  3b80              SUBS     r3,r3,#0x80
00007e  695b              LDR      r3,[r3,#0x14]
000080  2b00              CMP      r3,#0
000082  d101              BNE      |L1.136|
000084  466b              MOV      r3,sp
000086  7a19              LDRB     r1,[r3,#8]
                  |L1.136|
;;;99     				if(!PC1)	 u32Key = key_numeral[9];
000088  4b2e              LDR      r3,|L1.324|
00008a  3b40              SUBS     r3,r3,#0x40
00008c  685b              LDR      r3,[r3,#4]
00008e  2b00              CMP      r3,#0
000090  d101              BNE      |L1.150|
000092  466b              MOV      r3,sp
000094  7a59              LDRB     r1,[r3,#9]
                  |L1.150|
;;;100    				if(!PC8)	 u32Key = key_numeral[0];
000096  4b2b              LDR      r3,|L1.324|
000098  3b40              SUBS     r3,r3,#0x40
00009a  6a1b              LDR      r3,[r3,#0x20]
00009c  2b00              CMP      r3,#0
00009e  d101              BNE      |L1.164|
0000a0  466b              MOV      r3,sp
0000a2  7819              LDRB     r1,[r3,#0]
                  |L1.164|
;;;101    				if(!PA10)	 u32Key = 0x53; //Keypad Num Lock and Clear
0000a4  4b27              LDR      r3,|L1.324|
0000a6  3bc0              SUBS     r3,r3,#0xc0
0000a8  6a9b              LDR      r3,[r3,#0x28]
0000aa  2b00              CMP      r3,#0
0000ac  d100              BNE      |L1.176|
0000ae  2153              MOVS     r1,#0x53
                  |L1.176|
;;;102    				if(!PB4)	 u32Key = 0x54; //Keypad /
0000b0  4b24              LDR      r3,|L1.324|
0000b2  3b80              SUBS     r3,r3,#0x80
0000b4  691b              LDR      r3,[r3,#0x10]
0000b6  2b00              CMP      r3,#0
0000b8  d100              BNE      |L1.188|
0000ba  2154              MOVS     r1,#0x54
                  |L1.188|
;;;103    				if(!PC3)	 u32Key = 0x55; //Keypad *
0000bc  4b21              LDR      r3,|L1.324|
0000be  3b40              SUBS     r3,r3,#0x40
0000c0  68db              LDR      r3,[r3,#0xc]
0000c2  2b00              CMP      r3,#0
0000c4  d100              BNE      |L1.200|
0000c6  2155              MOVS     r1,#0x55
                  |L1.200|
;;;104    				if(!PC2)	 u32Key = 0x56;	//Keypad -
0000c8  4b1e              LDR      r3,|L1.324|
0000ca  3b40              SUBS     r3,r3,#0x40
0000cc  689b              LDR      r3,[r3,#8]
0000ce  2b00              CMP      r3,#0
0000d0  d100              BNE      |L1.212|
0000d2  2156              MOVS     r1,#0x56
                  |L1.212|
;;;105    				if(!PC0)	 u32Key = 0x57; //Keypad +
0000d4  4b1b              LDR      r3,|L1.324|
0000d6  3b40              SUBS     r3,r3,#0x40
0000d8  681b              LDR      r3,[r3,#0]
0000da  2b00              CMP      r3,#0
0000dc  d100              BNE      |L1.224|
0000de  2157              MOVS     r1,#0x57
                  |L1.224|
;;;106    				if(!PC12)	 u32Key = 0x58; //Keypad ENTER
0000e0  4b18              LDR      r3,|L1.324|
0000e2  3b40              SUBS     r3,r3,#0x40
0000e4  6b1b              LDR      r3,[r3,#0x30]
0000e6  2b00              CMP      r3,#0
0000e8  d100              BNE      |L1.236|
0000ea  2158              MOVS     r1,#0x58
                  |L1.236|
;;;107    				if(!PC11)	 u32Key = 0x63; //Keypad . and Delete
0000ec  4b15              LDR      r3,|L1.324|
0000ee  3b40              SUBS     r3,r3,#0x40
0000f0  6adb              LDR      r3,[r3,#0x2c]
0000f2  2b00              CMP      r3,#0
0000f4  d100              BNE      |L1.248|
0000f6  2163              MOVS     r1,#0x63
                  |L1.248|
;;;108    			
;;;109            if (u32Key == 0)
0000f8  2900              CMP      r1,#0
0000fa  d10f              BNE      |L1.284|
;;;110            {
;;;111                for (i = 0; i < 8; i++)
0000fc  2000              MOVS     r0,#0
0000fe  e003              B        |L1.264|
                  |L1.256|
000100  e00b              B        |L1.282|
                  |L1.258|
;;;112                {
;;;113                    pu8Buf[i] = 0;
000102  2300              MOVS     r3,#0
000104  5413              STRB     r3,[r2,r0]
000106  1c40              ADDS     r0,r0,#1              ;111
                  |L1.264|
000108  2808              CMP      r0,#8                 ;111
00010a  dbfa              BLT      |L1.258|
;;;114                }
;;;115    
;;;116                if (u32Key != u32PreKey)
00010c  4b0e              LDR      r3,|L1.328|
00010e  681b              LDR      r3,[r3,#0]  ; u32PreKey
000110  4299              CMP      r1,r3
000112  d009              BEQ      |L1.296|
;;;117                {
;;;118                    /* Trigger to note key release */
;;;119                    USBD_SET_PAYLOAD_LEN(EP2, 8);
000114  2308              MOVS     r3,#8
000116  4c09              LDR      r4,|L1.316|
000118  6263              STR      r3,[r4,#0x24]
                  |L1.282|
00011a  e005              B        |L1.296|
                  |L1.284|
;;;120                }
;;;121            }
;;;122            else
;;;123            {
;;;124                u32PreKey = u32Key;
00011c  4b0a              LDR      r3,|L1.328|
00011e  6019              STR      r1,[r3,#0]  ; u32PreKey
;;;125    						pu8Buf[2] = u32Key;
000120  7091              STRB     r1,[r2,#2]
;;;126                USBD_SET_PAYLOAD_LEN(EP2, 8);
000122  2308              MOVS     r3,#8
000124  4c05              LDR      r4,|L1.316|
000126  6263              STR      r3,[r4,#0x24]
                  |L1.296|
;;;127            }
;;;128        }
;;;129    }
000128  bd3e              POP      {r1-r5,pc}
;;;130    
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
00012c  62595a5b          DCB      "bYZ[\\]^_`a",0
000130  5c5d5e5f
000134  606100  
000137  00                DCB      0
                  |L1.312|
                          DCD      g_u8EP2Ready
                  |L1.316|
                          DCD      0x40060500
                  |L1.320|
                          DCD      0x40060100
                  |L1.324|
                          DCD      0x500042c0
                  |L1.328|
                          DCD      u32PreKey

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;20     
;;;21     void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;22     {
;;;23     
;;;24         /*---------------------------------------------------------------------------------------------------------*/
;;;25         /* Init System Clock                                                                                       */
;;;26         /*---------------------------------------------------------------------------------------------------------*/
;;;27     
;;;28         /* Enable Internal HIRC 48 MHz clock */
;;;29         CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       CLK_EnableXtalRC
;;;30     
;;;31         /* Waiting for Internal RC clock ready */
;;;32         CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       CLK_WaitClockReady
;;;33     
;;;34     #if (CRYSTAL_LESS)
;;;35         /* Switch HCLK clock source to Internal HIRC and HCLK source divide 1 */
;;;36         CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
00000e  2100              MOVS     r1,#0
000010  2004              MOVS     r0,#4
000012  f7fffffe          BL       CLK_SetHCLK
;;;37     
;;;38         /* Select module clock source */
;;;39         CLK_SetModuleClock(USBD_MODULE, CLK_CLKSEL3_USBDSEL_HIRC, CLK_CLKDIV0_USB(1));
000016  2200              MOVS     r2,#0
000018  4611              MOV      r1,r2
00001a  480e              LDR      r0,|L2.84|
00001c  f7fffffe          BL       CLK_SetModuleClock
;;;40     #else
;;;41         /* Enable External XTAL (4~24 MHz) */
;;;42         CLK_EnableXtalRC(CLK_PWRCTL_HXTEN);
;;;43     
;;;44         /* Waiting for 12MHz clock ready */
;;;45         CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;46     
;;;47         /* Set core clock as PLL_CLOCK from PLL */
;;;48         CLK_SetCoreClock(FREQ_48MHZ);
;;;49     
;;;50         /* Select module clock source */
;;;51         CLK_SetModuleClock(USBD_MODULE, CLK_CLKSEL3_USBDSEL_PLL, CLK_CLKDIV0_USB(2));
;;;52     #endif
;;;53     
;;;54         SystemCoreClockUpdate();
000020  f7fffffe          BL       SystemCoreClockUpdate
;;;55     
;;;56         /* Enable module clock */
;;;57         CLK_EnableModuleClock(UART0_MODULE);
000024  480c              LDR      r0,|L2.88|
000026  f7fffffe          BL       CLK_EnableModuleClock
;;;58         CLK_EnableModuleClock(USBD_MODULE);
00002a  480a              LDR      r0,|L2.84|
00002c  f7fffffe          BL       CLK_EnableModuleClock
;;;59     
;;;60         /* Select module clock source */
;;;61         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UARTSEL_HIRC_DIV2, CLK_CLKDIV0_UART(1));
000030  2200              MOVS     r2,#0
000032  2103              MOVS     r1,#3
000034  0609              LSLS     r1,r1,#24
000036  4808              LDR      r0,|L2.88|
000038  f7fffffe          BL       CLK_SetModuleClock
;;;62     
;;;63         /*---------------------------------------------------------------------------------------------------------*/
;;;64         /* Init I/O Multi-function                                                                                 */
;;;65         /*---------------------------------------------------------------------------------------------------------*/
;;;66     
;;;67         /* Set PB multi-function pins for UART0 RXD and TXD */
;;;68         SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk);
00003c  2005              MOVS     r0,#5
00003e  0700              LSLS     r0,r0,#28
000040  6b80              LDR      r0,[r0,#0x38]
000042  0a00              LSRS     r0,r0,#8
000044  0200              LSLS     r0,r0,#8
000046  2105              MOVS     r1,#5
000048  0709              LSLS     r1,r1,#28
00004a  6388              STR      r0,[r1,#0x38]
;;;69         SYS->GPB_MFPL = SYS_GPB_MFPL_PB0MFP_UART0_RXD | SYS_GPB_MFPL_PB1MFP_UART0_TXD;
00004c  2011              MOVS     r0,#0x11
00004e  6388              STR      r0,[r1,#0x38]
;;;70     
;;;71     
;;;72     }
000050  bd10              POP      {r4,pc}
;;;73     
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      0x72803c9b
                  |L2.88|
                          DCD      0x57803d10

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;133    /*---------------------------------------------------------------------------------------------------------*/
;;;134    int32_t main(void)
000000  bf00              NOP      
000002  bf00              NOP      
000004  bf00              NOP      
                  |L3.6|
000006  2059              MOVS     r0,#0x59
000008  4928              LDR      r1,|L3.172|
00000a  6008              STR      r0,[r1,#0]
00000c  2016              MOVS     r0,#0x16
00000e  6008              STR      r0,[r1,#0]
000010  2088              MOVS     r0,#0x88
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  2800              CMP      r0,#0
00001a  d0f4              BEQ      |L3.6|
00001c  bf00              NOP      
;;;135    {	
;;;136    #if CRYSTAL_LESS
;;;137        uint32_t u32TrimInit;
;;;138    #endif
;;;139        
;;;140        SYS_UnlockReg(); // Unlock protected registers
;;;141    
;;;142        SYS_Init();
00001e  f7fffffe          BL       SYS_Init
;;;143    
;;;144        USBD_Open(&gsInfo, HID_ClassRequest, NULL);
000022  2200              MOVS     r2,#0
000024  4922              LDR      r1,|L3.176|
000026  4823              LDR      r0,|L3.180|
000028  f7fffffe          BL       USBD_Open
;;;145    
;;;146        /* Endpoint configuration */
;;;147        HID_Init();
00002c  f7fffffe          BL       HID_Init
;;;148        USBD_Start();
000030  f7fffffe          BL       USBD_Start
;;;149    
;;;150        NVIC_EnableIRQ(USBD_IRQn);
000034  2017              MOVS     r0,#0x17
000036  2101              MOVS     r1,#1
000038  4081              LSLS     r1,r1,r0
00003a  4a1f              LDR      r2,|L3.184|
00003c  6011              STR      r1,[r2,#0]
00003e  bf00              NOP      
;;;151    
;;;152        /* start to IN data */
;;;153        g_u8EP2Ready = 1;
000040  2001              MOVS     r0,#1
000042  491e              LDR      r1,|L3.188|
000044  7008              STRB     r0,[r1,#0]
;;;154    
;;;155    #if CRYSTAL_LESS
;;;156        /* Backup default trim value */
;;;157        u32TrimInit = M32(TRIM_INIT);
000046  4819              LDR      r0,|L3.172|
000048  6904              LDR      r4,[r0,#0x10]
;;;158    
;;;159        /* Clear SOF */
;;;160        USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
00004a  2010              MOVS     r0,#0x10
00004c  491c              LDR      r1,|L3.192|
00004e  6048              STR      r0,[r1,#4]
;;;161    #endif
;;;162    
;;;163        while (1)
000050  e02b              B        |L3.170|
                  |L3.82|
;;;164        {
;;;165    #if CRYSTAL_LESS
;;;166    
;;;167            /* Start USB trim function if it is not enabled. */
;;;168            if ((SYS->IRCTCTL & SYS_IRCTCTL_FREQSEL_Msk) != 0x2)
000052  4816              LDR      r0,|L3.172|
000054  3880              SUBS     r0,r0,#0x80
000056  6800              LDR      r0,[r0,#0]
000058  0780              LSLS     r0,r0,#30
00005a  0f80              LSRS     r0,r0,#30
00005c  2802              CMP      r0,#2
00005e  d010              BEQ      |L3.130|
;;;169            {
;;;170                /* Start USB trim only when USB signal arrived */
;;;171                if (USBD->INTSTS & USBD_INTSTS_SOFIF_Msk)
000060  4817              LDR      r0,|L3.192|
000062  6840              LDR      r0,[r0,#4]
000064  2110              MOVS     r1,#0x10
000066  4008              ANDS     r0,r0,r1
000068  2800              CMP      r0,#0
00006a  d00a              BEQ      |L3.130|
;;;172                {
;;;173                    /* Clear SOF */
;;;174                    USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
00006c  2010              MOVS     r0,#0x10
00006e  4914              LDR      r1,|L3.192|
000070  6048              STR      r0,[r1,#4]
;;;175    
;;;176                    /* Enable USB clock trim function */
;;;177                    SYS->IRCTCTL |= (SYS_IRCTCTL_REFCKSEL_Msk | 0x2);
000072  480e              LDR      r0,|L3.172|
000074  3880              SUBS     r0,r0,#0x80
000076  6800              LDR      r0,[r0,#0]
000078  4912              LDR      r1,|L3.196|
00007a  4308              ORRS     r0,r0,r1
00007c  490b              LDR      r1,|L3.172|
00007e  3980              SUBS     r1,r1,#0x80
000080  6008              STR      r0,[r1,#0]
                  |L3.130|
;;;178                }
;;;179            }
;;;180    
;;;181            /* Disable USB Trim when any error found */
;;;182            if (SYS->IRCTISTS & (SYS_IRCTISTS_CLKERRIF_Msk | SYS_IRCTISTS_TFAILIF_Msk))
000082  480a              LDR      r0,|L3.172|
000084  3880              SUBS     r0,r0,#0x80
000086  6880              LDR      r0,[r0,#8]
000088  2106              MOVS     r1,#6
00008a  4008              ANDS     r0,r0,r1
00008c  2800              CMP      r0,#0
00008e  d00a              BEQ      |L3.166|
;;;183            {
;;;184                /* Init TRIM */
;;;185                M32(TRIM_INIT) = u32TrimInit;
000090  4806              LDR      r0,|L3.172|
000092  6104              STR      r4,[r0,#0x10]
;;;186    
;;;187                /* Disable USB clock trim function */
;;;188                SYS->IRCTCTL = 0;
000094  2000              MOVS     r0,#0
000096  4905              LDR      r1,|L3.172|
000098  3980              SUBS     r1,r1,#0x80
00009a  6008              STR      r0,[r1,#0]
;;;189    
;;;190                /* Clear trim error flags */
;;;191                SYS->IRCTISTS = SYS_IRCTISTS_CLKERRIF_Msk | SYS_IRCTISTS_TFAILIF_Msk;
00009c  2006              MOVS     r0,#6
00009e  6088              STR      r0,[r1,#8]
;;;192    
;;;193                /* Clear SOF */
;;;194                USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
0000a0  2010              MOVS     r0,#0x10
0000a2  4907              LDR      r1,|L3.192|
0000a4  6048              STR      r0,[r1,#4]
                  |L3.166|
;;;195    
;;;196            }
;;;197    
;;;198    #endif
;;;199            HID_UpdateKbData();
0000a6  f7fffffe          BL       HID_UpdateKbData
                  |L3.170|
0000aa  e7d2              B        |L3.82|
;;;200        }
;;;201    }
;;;202    
                          ENDP

                  |L3.172|
                          DCD      0x50000100
                  |L3.176|
                          DCD      HID_ClassRequest
                  |L3.180|
                          DCD      gsInfo
                  |L3.184|
                          DCD      0xe000e100
                  |L3.188|
                          DCD      g_u8EP2Ready
                  |L3.192|
                          DCD      0x40060000
                  |L3.196|
                          DCD      0x00000402

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8EP2Ready
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  u32PreKey
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6dbc9832____REV16|
#line 388 ".\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_6dbc9832____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6dbc9832____REVSH|
#line 402
|__asm___6_main_c_6dbc9832____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0

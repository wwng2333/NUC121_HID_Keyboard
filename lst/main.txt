; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\main.crf main.c]
                          THUMB

                          AREA ||i.HID_UpdateKbData||, CODE, READONLY, ALIGN=2

                  HID_UpdateKbData PROC
;;;87     
;;;88     void HID_UpdateKbData(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;89     {
;;;90         int32_t i;
;;;91         uint8_t *pu8Buf;
;;;92         uint32_t u32Key = 0xF;
000002  210f              MOVS     r1,#0xf
;;;93         static uint32_t u32PreKey;
;;;94     		//uint8_t key_numeral[10] = {0x27, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26};
;;;95     		uint8_t key_numeral[10] = {0x62, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61};
000004  a549              ADR      r5,|L1.300|
000006  cd38              LDM      r5,{r3-r5}
000008  4668              MOV      r0,sp
00000a  c038              STM      r0!,{r3-r5}
;;;96     
;;;97         if (g_u8EP2Ready)
00000c  4b4a              LDR      r3,|L1.312|
00000e  781b              LDRB     r3,[r3,#0]  ; g_u8EP2Ready
000010  2b00              CMP      r3,#0
000012  d075              BEQ      |L1.256|
;;;98         {
;;;99             pu8Buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP2));
000014  4b49              LDR      r3,|L1.316|
000016  6a1b              LDR      r3,[r3,#0x20]
000018  4c49              LDR      r4,|L1.320|
00001a  191a              ADDS     r2,r3,r4
;;;100    
;;;101            /* If PA.10 = 0, just report it is key 'a' and 'b' */
;;;102            //u32Key = (PA->PIN & (1 << 10)) ? 0 : 1;
;;;103    
;;;104    				u32Key = 0;
00001c  2100              MOVS     r1,#0
;;;105    				if(!PD2)	 u32Key = key_numeral[1];
00001e  4b49              LDR      r3,|L1.324|
000020  689b              LDR      r3,[r3,#8]
000022  2b00              CMP      r3,#0
000024  d101              BNE      |L1.42|
000026  466b              MOV      r3,sp
000028  7859              LDRB     r1,[r3,#1]
                  |L1.42|
;;;106    				if(!PD1)	 u32Key = key_numeral[2];
00002a  4b46              LDR      r3,|L1.324|
00002c  685b              LDR      r3,[r3,#4]
00002e  2b00              CMP      r3,#0
000030  d101              BNE      |L1.54|
000032  466b              MOV      r3,sp
000034  7899              LDRB     r1,[r3,#2]
                  |L1.54|
;;;107    				if(!PC10)	 u32Key = key_numeral[3];
000036  4b43              LDR      r3,|L1.324|
000038  3b40              SUBS     r3,r3,#0x40
00003a  6a9b              LDR      r3,[r3,#0x28]
00003c  2b00              CMP      r3,#0
00003e  d101              BNE      |L1.68|
000040  466b              MOV      r3,sp
000042  78d9              LDRB     r1,[r3,#3]
                  |L1.68|
;;;108    				if(!PB14)	 u32Key = key_numeral[4];
000044  4b3f              LDR      r3,|L1.324|
000046  3b80              SUBS     r3,r3,#0x80
000048  6b9b              LDR      r3,[r3,#0x38]
00004a  2b00              CMP      r3,#0
00004c  d101              BNE      |L1.82|
00004e  466b              MOV      r3,sp
000050  7919              LDRB     r1,[r3,#4]
                  |L1.82|
;;;109    				if(!PD3)	 u32Key = key_numeral[5];
000052  4b3c              LDR      r3,|L1.324|
000054  68db              LDR      r3,[r3,#0xc]
000056  2b00              CMP      r3,#0
000058  d101              BNE      |L1.94|
00005a  466b              MOV      r3,sp
00005c  7959              LDRB     r1,[r3,#5]
                  |L1.94|
;;;110    				if(!PC9)	 u32Key = key_numeral[6];
00005e  4b39              LDR      r3,|L1.324|
000060  3b40              SUBS     r3,r3,#0x40
000062  6a5b              LDR      r3,[r3,#0x24]
000064  2b00              CMP      r3,#0
000066  d101              BNE      |L1.108|
000068  466b              MOV      r3,sp
00006a  7999              LDRB     r1,[r3,#6]
                  |L1.108|
;;;111    				if(!PA11)	 u32Key = key_numeral[7];
00006c  4b35              LDR      r3,|L1.324|
00006e  3bc0              SUBS     r3,r3,#0xc0
000070  6adb              LDR      r3,[r3,#0x2c]
000072  2b00              CMP      r3,#0
000074  d101              BNE      |L1.122|
000076  466b              MOV      r3,sp
000078  79d9              LDRB     r1,[r3,#7]
                  |L1.122|
;;;112    				if(!PB5)	 u32Key = key_numeral[8];
00007a  4b32              LDR      r3,|L1.324|
00007c  3b80              SUBS     r3,r3,#0x80
00007e  695b              LDR      r3,[r3,#0x14]
000080  2b00              CMP      r3,#0
000082  d101              BNE      |L1.136|
000084  466b              MOV      r3,sp
000086  7a19              LDRB     r1,[r3,#8]
                  |L1.136|
;;;113    				if(!PC1)	 u32Key = key_numeral[9];
000088  4b2e              LDR      r3,|L1.324|
00008a  3b40              SUBS     r3,r3,#0x40
00008c  685b              LDR      r3,[r3,#4]
00008e  2b00              CMP      r3,#0
000090  d101              BNE      |L1.150|
000092  466b              MOV      r3,sp
000094  7a59              LDRB     r1,[r3,#9]
                  |L1.150|
;;;114    				if(!PC8)	 u32Key = key_numeral[0];
000096  4b2b              LDR      r3,|L1.324|
000098  3b40              SUBS     r3,r3,#0x40
00009a  6a1b              LDR      r3,[r3,#0x20]
00009c  2b00              CMP      r3,#0
00009e  d101              BNE      |L1.164|
0000a0  466b              MOV      r3,sp
0000a2  7819              LDRB     r1,[r3,#0]
                  |L1.164|
;;;115    				if(!PA10)	 u32Key = 0x53; //Keypad Num Lock and Clear
0000a4  4b27              LDR      r3,|L1.324|
0000a6  3bc0              SUBS     r3,r3,#0xc0
0000a8  6a9b              LDR      r3,[r3,#0x28]
0000aa  2b00              CMP      r3,#0
0000ac  d100              BNE      |L1.176|
0000ae  2153              MOVS     r1,#0x53
                  |L1.176|
;;;116    				if(!PB4)	 u32Key = 0x54; //Keypad /
0000b0  4b24              LDR      r3,|L1.324|
0000b2  3b80              SUBS     r3,r3,#0x80
0000b4  691b              LDR      r3,[r3,#0x10]
0000b6  2b00              CMP      r3,#0
0000b8  d100              BNE      |L1.188|
0000ba  2154              MOVS     r1,#0x54
                  |L1.188|
;;;117    				if(!PC3)	 u32Key = 0x55; //Keypad *
0000bc  4b21              LDR      r3,|L1.324|
0000be  3b40              SUBS     r3,r3,#0x40
0000c0  68db              LDR      r3,[r3,#0xc]
0000c2  2b00              CMP      r3,#0
0000c4  d100              BNE      |L1.200|
0000c6  2155              MOVS     r1,#0x55
                  |L1.200|
;;;118    				if(!PC2)	 u32Key = 0x56;	//Keypad -
0000c8  4b1e              LDR      r3,|L1.324|
0000ca  3b40              SUBS     r3,r3,#0x40
0000cc  689b              LDR      r3,[r3,#8]
0000ce  2b00              CMP      r3,#0
0000d0  d100              BNE      |L1.212|
0000d2  2156              MOVS     r1,#0x56
                  |L1.212|
;;;119    				if(!PC0)	 u32Key = 0x57; //Keypad +
0000d4  4b1b              LDR      r3,|L1.324|
0000d6  3b40              SUBS     r3,r3,#0x40
0000d8  681b              LDR      r3,[r3,#0]
0000da  2b00              CMP      r3,#0
0000dc  d100              BNE      |L1.224|
0000de  2157              MOVS     r1,#0x57
                  |L1.224|
;;;120    				if(!PC12)	 u32Key = 0x58; //Keypad ENTER
0000e0  4b18              LDR      r3,|L1.324|
0000e2  3b40              SUBS     r3,r3,#0x40
0000e4  6b1b              LDR      r3,[r3,#0x30]
0000e6  2b00              CMP      r3,#0
0000e8  d100              BNE      |L1.236|
0000ea  2158              MOVS     r1,#0x58
                  |L1.236|
;;;121    				if(!PC11)	 u32Key = 0x63; //Keypad . and Delete
0000ec  4b15              LDR      r3,|L1.324|
0000ee  3b40              SUBS     r3,r3,#0x40
0000f0  6adb              LDR      r3,[r3,#0x2c]
0000f2  2b00              CMP      r3,#0
0000f4  d100              BNE      |L1.248|
0000f6  2163              MOVS     r1,#0x63
                  |L1.248|
;;;122    			
;;;123            if (u32Key == 0)
0000f8  2900              CMP      r1,#0
0000fa  d10f              BNE      |L1.284|
;;;124            {
;;;125                for (i = 0; i < 8; i++)
0000fc  2000              MOVS     r0,#0
0000fe  e003              B        |L1.264|
                  |L1.256|
000100  e00b              B        |L1.282|
                  |L1.258|
;;;126                {
;;;127                    pu8Buf[i] = 0;
000102  2300              MOVS     r3,#0
000104  5413              STRB     r3,[r2,r0]
000106  1c40              ADDS     r0,r0,#1              ;125
                  |L1.264|
000108  2808              CMP      r0,#8                 ;125
00010a  dbfa              BLT      |L1.258|
;;;128                }
;;;129    
;;;130                if (u32Key != u32PreKey)
00010c  4b0e              LDR      r3,|L1.328|
00010e  681b              LDR      r3,[r3,#0]  ; u32PreKey
000110  4299              CMP      r1,r3
000112  d009              BEQ      |L1.296|
;;;131                {
;;;132                    /* Trigger to note key release */
;;;133                    USBD_SET_PAYLOAD_LEN(EP2, 8);
000114  2308              MOVS     r3,#8
000116  4c09              LDR      r4,|L1.316|
000118  6263              STR      r3,[r4,#0x24]
                  |L1.282|
00011a  e005              B        |L1.296|
                  |L1.284|
;;;134                }
;;;135            }
;;;136            else
;;;137            {
;;;138                u32PreKey = u32Key;
00011c  4b0a              LDR      r3,|L1.328|
00011e  6019              STR      r1,[r3,#0]  ; u32PreKey
;;;139    						pu8Buf[2] = u32Key;
000120  7091              STRB     r1,[r2,#2]
;;;140                USBD_SET_PAYLOAD_LEN(EP2, 8);
000122  2308              MOVS     r3,#8
000124  4c05              LDR      r4,|L1.316|
000126  6263              STR      r3,[r4,#0x24]
                  |L1.296|
;;;141            }
;;;142        }
;;;143    }
000128  bd3e              POP      {r1-r5,pc}
;;;144    
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
00012c  62595a5b          DCB      "bYZ[\\]^_`a",0
000130  5c5d5e5f
000134  606100  
000137  00                DCB      0
                  |L1.312|
                          DCD      g_u8EP2Ready
                  |L1.316|
                          DCD      0x40060500
                  |L1.320|
                          DCD      0x40060100
                  |L1.324|
                          DCD      0x500042c0
                  |L1.328|
                          DCD      u32PreKey

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;19     
;;;20     void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;21     {
;;;22     
;;;23         /*---------------------------------------------------------------------------------------------------------*/
;;;24         /* Init System Clock                                                                                       */
;;;25         /*---------------------------------------------------------------------------------------------------------*/
;;;26     
;;;27         /* Enable Internal HIRC 48 MHz clock */
;;;28         CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       CLK_EnableXtalRC
;;;29     
;;;30         /* Waiting for Internal RC clock ready */
;;;31         CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       CLK_WaitClockReady
;;;32     
;;;33     #if (CRYSTAL_LESS)
;;;34         /* Switch HCLK clock source to Internal HIRC and HCLK source divide 1 */
;;;35         CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
00000e  2100              MOVS     r1,#0
000010  2004              MOVS     r0,#4
000012  f7fffffe          BL       CLK_SetHCLK
;;;36     
;;;37         /* Select module clock source */
;;;38         CLK_SetModuleClock(USBD_MODULE, CLK_CLKSEL3_USBDSEL_HIRC, CLK_CLKDIV0_USB(1));
000016  2200              MOVS     r2,#0
000018  4611              MOV      r1,r2
00001a  480e              LDR      r0,|L2.84|
00001c  f7fffffe          BL       CLK_SetModuleClock
;;;39     #else
;;;40         /* Enable External XTAL (4~24 MHz) */
;;;41         CLK_EnableXtalRC(CLK_PWRCTL_HXTEN);
;;;42     
;;;43         /* Waiting for 12MHz clock ready */
;;;44         CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;45     
;;;46         /* Set core clock as PLL_CLOCK from PLL */
;;;47         CLK_SetCoreClock(FREQ_48MHZ);
;;;48     
;;;49         /* Select module clock source */
;;;50         CLK_SetModuleClock(USBD_MODULE, CLK_CLKSEL3_USBDSEL_PLL, CLK_CLKDIV0_USB(2));
;;;51     #endif
;;;52     
;;;53         SystemCoreClockUpdate();
000020  f7fffffe          BL       SystemCoreClockUpdate
;;;54     
;;;55         /* Enable module clock */
;;;56         CLK_EnableModuleClock(UART0_MODULE);
000024  480c              LDR      r0,|L2.88|
000026  f7fffffe          BL       CLK_EnableModuleClock
;;;57         CLK_EnableModuleClock(USBD_MODULE);
00002a  480a              LDR      r0,|L2.84|
00002c  f7fffffe          BL       CLK_EnableModuleClock
;;;58     
;;;59         /* Select module clock source */
;;;60         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UARTSEL_HIRC_DIV2, CLK_CLKDIV0_UART(1));
000030  2200              MOVS     r2,#0
000032  2103              MOVS     r1,#3
000034  0609              LSLS     r1,r1,#24
000036  4808              LDR      r0,|L2.88|
000038  f7fffffe          BL       CLK_SetModuleClock
;;;61     
;;;62         /*---------------------------------------------------------------------------------------------------------*/
;;;63         /* Init I/O Multi-function                                                                                 */
;;;64         /*---------------------------------------------------------------------------------------------------------*/
;;;65     
;;;66         /* Set PB multi-function pins for UART0 RXD and TXD */
;;;67         SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk);
00003c  2005              MOVS     r0,#5
00003e  0700              LSLS     r0,r0,#28
000040  6b80              LDR      r0,[r0,#0x38]
000042  0a00              LSRS     r0,r0,#8
000044  0200              LSLS     r0,r0,#8
000046  2105              MOVS     r1,#5
000048  0709              LSLS     r1,r1,#28
00004a  6388              STR      r0,[r1,#0x38]
;;;68         SYS->GPB_MFPL = SYS_GPB_MFPL_PB0MFP_UART0_RXD | SYS_GPB_MFPL_PB1MFP_UART0_TXD;
00004c  2011              MOVS     r0,#0x11
00004e  6388              STR      r0,[r1,#0x38]
;;;69     
;;;70     
;;;71     }
000050  bd10              POP      {r4,pc}
;;;72     
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      0x72803c9b
                  |L2.88|
                          DCD      0x57803d10

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;73     
;;;74     void UART0_Init(void)
000000  2005              MOVS     r0,#5
;;;75     {
;;;76         /*---------------------------------------------------------------------------------------------------------*/
;;;77         /* Init UART                                                                                               */
;;;78         /*---------------------------------------------------------------------------------------------------------*/
;;;79         /* Reset IP */
;;;80         SYS->IPRST1 |=  SYS_IPRST1_UART0RST_Msk;
000002  0700              LSLS     r0,r0,#28
000004  68c0              LDR      r0,[r0,#0xc]
000006  2101              MOVS     r1,#1
000008  0409              LSLS     r1,r1,#16
00000a  4308              ORRS     r0,r0,r1
00000c  2105              MOVS     r1,#5
00000e  0709              LSLS     r1,r1,#28
000010  60c8              STR      r0,[r1,#0xc]
;;;81         SYS->IPRST1 &= ~SYS_IPRST1_UART0RST_Msk;
000012  4608              MOV      r0,r1
000014  68c0              LDR      r0,[r0,#0xc]
000016  2101              MOVS     r1,#1
000018  0409              LSLS     r1,r1,#16
00001a  4388              BICS     r0,r0,r1
00001c  2105              MOVS     r1,#5
00001e  0709              LSLS     r1,r1,#28
000020  60c8              STR      r0,[r1,#0xc]
;;;82     
;;;83         /* Configure UART0 and set UART0 Baudrate */
;;;84         UART0->BAUD = UART_BAUD_MODE2 | UART_BAUD_MODE2_DIVIDER(__HIRC_DIV2, 115200);
000022  4803              LDR      r0,|L3.48|
000024  4903              LDR      r1,|L3.52|
000026  6248              STR      r0,[r1,#0x24]
;;;85         UART0->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
000028  2003              MOVS     r0,#3
00002a  60c8              STR      r0,[r1,#0xc]
;;;86     }
00002c  4770              BX       lr
;;;87     
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      0x300000ce
                  |L3.52|
                          DCD      0x40050000

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;147    /*---------------------------------------------------------------------------------------------------------*/
;;;148    int32_t main(void)
000000  bf00              NOP      
000002  bf00              NOP      
000004  bf00              NOP      
                  |L4.6|
000006  2059              MOVS     r0,#0x59
000008  492a              LDR      r1,|L4.180|
00000a  6008              STR      r0,[r1,#0]
00000c  2016              MOVS     r0,#0x16
00000e  6008              STR      r0,[r1,#0]
000010  2088              MOVS     r0,#0x88
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  2800              CMP      r0,#0
00001a  d0f4              BEQ      |L4.6|
00001c  bf00              NOP      
;;;149    {
;;;150    #if CRYSTAL_LESS
;;;151        uint32_t u32TrimInit;
;;;152    #endif
;;;153        /* Unlock protected registers */
;;;154        SYS_UnlockReg();
;;;155    
;;;156        SYS_Init();
00001e  f7fffffe          BL       SYS_Init
;;;157    	
;;;158    		PC13 = 1; //NUM LOCK LED
000022  2001              MOVS     r0,#1
000024  4924              LDR      r1,|L4.184|
000026  6348              STR      r0,[r1,#0x34]
;;;159    	
;;;160        /**
;;;161    	UART0_Init();
;;;162    
;;;163        printf("\n");
;;;164        printf("+--------------------------------------------------------+\n");
;;;165        printf("|          NuMicro USB HID Keyboard Sample Code          |\n");
;;;166        printf("+--------------------------------------------------------+\n");
;;;167        printf("If PB.15 = 0, just report it is key 'a'.\n");
;;;168    	**/
;;;169    
;;;170        USBD_Open(&gsInfo, HID_ClassRequest, NULL);
000028  2200              MOVS     r2,#0
00002a  4924              LDR      r1,|L4.188|
00002c  4824              LDR      r0,|L4.192|
00002e  f7fffffe          BL       USBD_Open
;;;171    
;;;172        /* Endpoint configuration */
;;;173        HID_Init();
000032  f7fffffe          BL       HID_Init
;;;174        USBD_Start();
000036  f7fffffe          BL       USBD_Start
;;;175    
;;;176        NVIC_EnableIRQ(USBD_IRQn);
00003a  2017              MOVS     r0,#0x17
00003c  2101              MOVS     r1,#1
00003e  4081              LSLS     r1,r1,r0
000040  4a20              LDR      r2,|L4.196|
000042  6011              STR      r1,[r2,#0]
000044  bf00              NOP      
;;;177    
;;;178        /* start to IN data */
;;;179        g_u8EP2Ready = 1;
000046  2001              MOVS     r0,#1
000048  491f              LDR      r1,|L4.200|
00004a  7008              STRB     r0,[r1,#0]
;;;180    
;;;181    #if CRYSTAL_LESS
;;;182        /* Backup default trim value */
;;;183        u32TrimInit = M32(TRIM_INIT);
00004c  4819              LDR      r0,|L4.180|
00004e  6904              LDR      r4,[r0,#0x10]
;;;184    
;;;185        /* Clear SOF */
;;;186        USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
000050  2010              MOVS     r0,#0x10
000052  491e              LDR      r1,|L4.204|
000054  6048              STR      r0,[r1,#4]
;;;187    #endif
;;;188    
;;;189        while (1)
000056  e02b              B        |L4.176|
                  |L4.88|
;;;190        {
;;;191    #if CRYSTAL_LESS
;;;192    
;;;193            /* Start USB trim function if it is not enabled. */
;;;194            if ((SYS->IRCTCTL & SYS_IRCTCTL_FREQSEL_Msk) != 0x2)
000058  4816              LDR      r0,|L4.180|
00005a  3880              SUBS     r0,r0,#0x80
00005c  6800              LDR      r0,[r0,#0]
00005e  0780              LSLS     r0,r0,#30
000060  0f80              LSRS     r0,r0,#30
000062  2802              CMP      r0,#2
000064  d010              BEQ      |L4.136|
;;;195            {
;;;196                /* Start USB trim only when USB signal arrived */
;;;197                if (USBD->INTSTS & USBD_INTSTS_SOFIF_Msk)
000066  4819              LDR      r0,|L4.204|
000068  6840              LDR      r0,[r0,#4]
00006a  2110              MOVS     r1,#0x10
00006c  4008              ANDS     r0,r0,r1
00006e  2800              CMP      r0,#0
000070  d00a              BEQ      |L4.136|
;;;198                {
;;;199                    /* Clear SOF */
;;;200                    USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
000072  2010              MOVS     r0,#0x10
000074  4915              LDR      r1,|L4.204|
000076  6048              STR      r0,[r1,#4]
;;;201    
;;;202                    /* Enable USB clock trim function */
;;;203                    SYS->IRCTCTL |= (SYS_IRCTCTL_REFCKSEL_Msk | 0x2);
000078  480e              LDR      r0,|L4.180|
00007a  3880              SUBS     r0,r0,#0x80
00007c  6800              LDR      r0,[r0,#0]
00007e  4914              LDR      r1,|L4.208|
000080  4308              ORRS     r0,r0,r1
000082  490c              LDR      r1,|L4.180|
000084  3980              SUBS     r1,r1,#0x80
000086  6008              STR      r0,[r1,#0]
                  |L4.136|
;;;204                }
;;;205            }
;;;206    
;;;207            /* Disable USB Trim when any error found */
;;;208            if (SYS->IRCTISTS & (SYS_IRCTISTS_CLKERRIF_Msk | SYS_IRCTISTS_TFAILIF_Msk))
000088  480a              LDR      r0,|L4.180|
00008a  3880              SUBS     r0,r0,#0x80
00008c  6880              LDR      r0,[r0,#8]
00008e  2106              MOVS     r1,#6
000090  4008              ANDS     r0,r0,r1
000092  2800              CMP      r0,#0
000094  d00a              BEQ      |L4.172|
;;;209            {
;;;210                /* Init TRIM */
;;;211                M32(TRIM_INIT) = u32TrimInit;
000096  4807              LDR      r0,|L4.180|
000098  6104              STR      r4,[r0,#0x10]
;;;212    
;;;213                /* Disable USB clock trim function */
;;;214                SYS->IRCTCTL = 0;
00009a  2000              MOVS     r0,#0
00009c  4905              LDR      r1,|L4.180|
00009e  3980              SUBS     r1,r1,#0x80
0000a0  6008              STR      r0,[r1,#0]
;;;215    
;;;216                /* Clear trim error flags */
;;;217                SYS->IRCTISTS = SYS_IRCTISTS_CLKERRIF_Msk | SYS_IRCTISTS_TFAILIF_Msk;
0000a2  2006              MOVS     r0,#6
0000a4  6088              STR      r0,[r1,#8]
;;;218    
;;;219                /* Clear SOF */
;;;220                USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
0000a6  2010              MOVS     r0,#0x10
0000a8  4908              LDR      r1,|L4.204|
0000aa  6048              STR      r0,[r1,#4]
                  |L4.172|
;;;221    
;;;222            }
;;;223    
;;;224    #endif
;;;225            HID_UpdateKbData();
0000ac  f7fffffe          BL       HID_UpdateKbData
                  |L4.176|
0000b0  e7d2              B        |L4.88|
;;;226        }
;;;227    }
;;;228    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L4.180|
                          DCD      0x50000100
                  |L4.184|
                          DCD      0x50004280
                  |L4.188|
                          DCD      HID_ClassRequest
                  |L4.192|
                          DCD      gsInfo
                  |L4.196|
                          DCD      0xe000e100
                  |L4.200|
                          DCD      g_u8EP2Ready
                  |L4.204|
                          DCD      0x40060000
                  |L4.208|
                          DCD      0x00000402

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8EP2Ready
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  u32PreKey
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6dbc9832____REV16|
#line 388 ".\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_6dbc9832____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6dbc9832____REVSH|
#line 402
|__asm___6_main_c_6dbc9832____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0

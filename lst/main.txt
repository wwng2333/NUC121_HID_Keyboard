; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC121\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\ARM\RV31\INC -IC:\Keil_v5\ARM\ARM\CMSIS\Include -IC:\Keil_v5\ARM\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=529 --omf_browse=.\obj\main.crf main.c]
                          THUMB

                          AREA ||i.HID_UpdateKbData||, CODE, READONLY, ALIGN=2

                  HID_UpdateKbData PROC
;;;88     
;;;89     void HID_UpdateKbData(void)
000000  b510              PUSH     {r4,lr}
;;;90     {
;;;91         int32_t i;
;;;92         uint8_t *pu8Buf;
;;;93         uint32_t u32Key = 0xF;
000002  220f              MOVS     r2,#0xf
;;;94         static uint32_t u32PreKey;
;;;95     
;;;96         if (g_u8EP2Ready)
000004  4b13              LDR      r3,|L1.84|
000006  781b              LDRB     r3,[r3,#0]  ; g_u8EP2Ready
000008  2b00              CMP      r3,#0
00000a  d021              BEQ      |L1.80|
;;;97         {
;;;98             pu8Buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP2));
00000c  4b12              LDR      r3,|L1.88|
00000e  6a1b              LDR      r3,[r3,#0x20]
000010  4c12              LDR      r4,|L1.92|
000012  1919              ADDS     r1,r3,r4
;;;99     
;;;100            /* If PB.15 = 0, just report it is key 'a' */
;;;101            u32Key = (PB->PIN & (1 << 15)) ? 0 : 1;
000014  4b12              LDR      r3,|L1.96|
000016  691b              LDR      r3,[r3,#0x10]
000018  0bdc              LSRS     r4,r3,#15
00001a  2301              MOVS     r3,#1
00001c  43a3              BICS     r3,r3,r4
00001e  461a              MOV      r2,r3
;;;102    
;;;103            if (u32Key == 0)
000020  2a00              CMP      r2,#0
000022  d10e              BNE      |L1.66|
;;;104            {
;;;105                for (i = 0; i < 8; i++)
000024  2000              MOVS     r0,#0
000026  e002              B        |L1.46|
                  |L1.40|
;;;106                {
;;;107                    pu8Buf[i] = 0;
000028  2300              MOVS     r3,#0
00002a  540b              STRB     r3,[r1,r0]
00002c  1c40              ADDS     r0,r0,#1              ;105
                  |L1.46|
00002e  2808              CMP      r0,#8                 ;105
000030  dbfa              BLT      |L1.40|
;;;108                }
;;;109    
;;;110                if (u32Key != u32PreKey)
000032  4b0c              LDR      r3,|L1.100|
000034  681b              LDR      r3,[r3,#0]  ; u32PreKey
000036  429a              CMP      r2,r3
000038  d00a              BEQ      |L1.80|
;;;111                {
;;;112                    /* Trigger to note key release */
;;;113                    USBD_SET_PAYLOAD_LEN(EP2, 8);
00003a  2308              MOVS     r3,#8
00003c  4c06              LDR      r4,|L1.88|
00003e  6263              STR      r3,[r4,#0x24]
000040  e006              B        |L1.80|
                  |L1.66|
;;;114                }
;;;115            }
;;;116            else
;;;117            {
;;;118                u32PreKey = u32Key;
000042  4b08              LDR      r3,|L1.100|
000044  601a              STR      r2,[r3,#0]  ; u32PreKey
;;;119                pu8Buf[2] = 0x04; /* Key A */
000046  2304              MOVS     r3,#4
000048  708b              STRB     r3,[r1,#2]
;;;120                USBD_SET_PAYLOAD_LEN(EP2, 8);
00004a  2308              MOVS     r3,#8
00004c  4c02              LDR      r4,|L1.88|
00004e  6263              STR      r3,[r4,#0x24]
                  |L1.80|
;;;121            }
;;;122        }
;;;123    }
000050  bd10              POP      {r4,pc}
;;;124    
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
                          DCD      g_u8EP2Ready
                  |L1.88|
                          DCD      0x40060500
                  |L1.92|
                          DCD      0x40060100
                  |L1.96|
                          DCD      0x50004040
                  |L1.100|
                          DCD      u32PreKey

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;19     
;;;20     void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;21     {
;;;22     
;;;23         /*---------------------------------------------------------------------------------------------------------*/
;;;24         /* Init System Clock                                                                                       */
;;;25         /*---------------------------------------------------------------------------------------------------------*/
;;;26     
;;;27         /* Enable Internal HIRC 48 MHz clock */
;;;28         CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       CLK_EnableXtalRC
;;;29     
;;;30         /* Waiting for Internal RC clock ready */
;;;31         CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       CLK_WaitClockReady
;;;32     
;;;33     #if (CRYSTAL_LESS)
;;;34         /* Switch HCLK clock source to Internal HIRC and HCLK source divide 1 */
;;;35         CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
00000e  2100              MOVS     r1,#0
000010  2004              MOVS     r0,#4
000012  f7fffffe          BL       CLK_SetHCLK
;;;36     
;;;37         /* Select module clock source */
;;;38         CLK_SetModuleClock(USBD_MODULE, CLK_CLKSEL3_USBDSEL_HIRC, CLK_CLKDIV0_USB(1));
000016  2200              MOVS     r2,#0
000018  4611              MOV      r1,r2
00001a  480e              LDR      r0,|L2.84|
00001c  f7fffffe          BL       CLK_SetModuleClock
;;;39     #else
;;;40         /* Enable External XTAL (4~24 MHz) */
;;;41         CLK_EnableXtalRC(CLK_PWRCTL_HXTEN);
;;;42     
;;;43         /* Waiting for 12MHz clock ready */
;;;44         CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;45     
;;;46         /* Set core clock as PLL_CLOCK from PLL */
;;;47         CLK_SetCoreClock(FREQ_48MHZ);
;;;48     
;;;49         /* Select module clock source */
;;;50         CLK_SetModuleClock(USBD_MODULE, CLK_CLKSEL3_USBDSEL_PLL, CLK_CLKDIV0_USB(2));
;;;51     #endif
;;;52     
;;;53         SystemCoreClockUpdate();
000020  f7fffffe          BL       SystemCoreClockUpdate
;;;54     
;;;55         /* Enable module clock */
;;;56         CLK_EnableModuleClock(UART0_MODULE);
000024  480c              LDR      r0,|L2.88|
000026  f7fffffe          BL       CLK_EnableModuleClock
;;;57         CLK_EnableModuleClock(USBD_MODULE);
00002a  480a              LDR      r0,|L2.84|
00002c  f7fffffe          BL       CLK_EnableModuleClock
;;;58     
;;;59         /* Select module clock source */
;;;60         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UARTSEL_HIRC_DIV2, CLK_CLKDIV0_UART(1));
000030  2200              MOVS     r2,#0
000032  2103              MOVS     r1,#3
000034  0609              LSLS     r1,r1,#24
000036  4808              LDR      r0,|L2.88|
000038  f7fffffe          BL       CLK_SetModuleClock
;;;61     
;;;62         /*---------------------------------------------------------------------------------------------------------*/
;;;63         /* Init I/O Multi-function                                                                                 */
;;;64         /*---------------------------------------------------------------------------------------------------------*/
;;;65     
;;;66         /* Set PB multi-function pins for UART0 RXD and TXD */
;;;67         SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk);
00003c  2005              MOVS     r0,#5
00003e  0700              LSLS     r0,r0,#28
000040  6b80              LDR      r0,[r0,#0x38]
000042  0a00              LSRS     r0,r0,#8
000044  0200              LSLS     r0,r0,#8
000046  2105              MOVS     r1,#5
000048  0709              LSLS     r1,r1,#28
00004a  6388              STR      r0,[r1,#0x38]
;;;68         SYS->GPB_MFPL = SYS_GPB_MFPL_PB0MFP_UART0_RXD | SYS_GPB_MFPL_PB1MFP_UART0_TXD;
00004c  2011              MOVS     r0,#0x11
00004e  6388              STR      r0,[r1,#0x38]
;;;69     
;;;70     
;;;71     }
000050  bd10              POP      {r4,pc}
;;;72     
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      0x72803c9b
                  |L2.88|
                          DCD      0x57803d10

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;73     
;;;74     void UART0_Init(void)
000000  2005              MOVS     r0,#5
;;;75     {
;;;76         /*---------------------------------------------------------------------------------------------------------*/
;;;77         /* Init UART                                                                                               */
;;;78         /*---------------------------------------------------------------------------------------------------------*/
;;;79         /* Reset IP */
;;;80         SYS->IPRST1 |=  SYS_IPRST1_UART0RST_Msk;
000002  0700              LSLS     r0,r0,#28
000004  68c0              LDR      r0,[r0,#0xc]
000006  2101              MOVS     r1,#1
000008  0409              LSLS     r1,r1,#16
00000a  4308              ORRS     r0,r0,r1
00000c  2105              MOVS     r1,#5
00000e  0709              LSLS     r1,r1,#28
000010  60c8              STR      r0,[r1,#0xc]
;;;81         SYS->IPRST1 &= ~SYS_IPRST1_UART0RST_Msk;
000012  4608              MOV      r0,r1
000014  68c0              LDR      r0,[r0,#0xc]
000016  2101              MOVS     r1,#1
000018  0409              LSLS     r1,r1,#16
00001a  4388              BICS     r0,r0,r1
00001c  2105              MOVS     r1,#5
00001e  0709              LSLS     r1,r1,#28
000020  60c8              STR      r0,[r1,#0xc]
;;;82     
;;;83         /* Configure UART0 and set UART0 Baudrate */
;;;84         UART0->BAUD = UART_BAUD_MODE2 | UART_BAUD_MODE2_DIVIDER(__HIRC_DIV2, 115200);
000022  4803              LDR      r0,|L3.48|
000024  4903              LDR      r1,|L3.52|
000026  6248              STR      r0,[r1,#0x24]
;;;85         UART0->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
000028  2003              MOVS     r0,#3
00002a  60c8              STR      r0,[r1,#0xc]
;;;86     }
00002c  4770              BX       lr
;;;87     
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      0x300000ce
                  |L3.52|
                          DCD      0x40050000

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;127    /*---------------------------------------------------------------------------------------------------------*/
;;;128    int32_t main(void)
000000  bf00              NOP      
000002  bf00              NOP      
000004  bf00              NOP      
                  |L4.6|
000006  2059              MOVS     r0,#0x59
000008  4928              LDR      r1,|L4.172|
00000a  6008              STR      r0,[r1,#0]
00000c  2016              MOVS     r0,#0x16
00000e  6008              STR      r0,[r1,#0]
000010  2088              MOVS     r0,#0x88
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  2800              CMP      r0,#0
00001a  d0f4              BEQ      |L4.6|
00001c  bf00              NOP      
;;;129    {
;;;130    #if CRYSTAL_LESS
;;;131        uint32_t u32TrimInit;
;;;132    #endif
;;;133        /* Unlock protected registers */
;;;134        SYS_UnlockReg();
;;;135    
;;;136        SYS_Init();
00001e  f7fffffe          BL       SYS_Init
;;;137    	
;;;138        /**
;;;139    	UART0_Init();
;;;140    
;;;141        printf("\n");
;;;142        printf("+--------------------------------------------------------+\n");
;;;143        printf("|          NuMicro USB HID Keyboard Sample Code          |\n");
;;;144        printf("+--------------------------------------------------------+\n");
;;;145        printf("If PB.15 = 0, just report it is key 'a'.\n");
;;;146    	**/
;;;147    
;;;148        USBD_Open(&gsInfo, HID_ClassRequest, NULL);
000022  2200              MOVS     r2,#0
000024  4922              LDR      r1,|L4.176|
000026  4823              LDR      r0,|L4.180|
000028  f7fffffe          BL       USBD_Open
;;;149    
;;;150        /* Endpoint configuration */
;;;151        HID_Init();
00002c  f7fffffe          BL       HID_Init
;;;152        USBD_Start();
000030  f7fffffe          BL       USBD_Start
;;;153    
;;;154        NVIC_EnableIRQ(USBD_IRQn);
000034  2017              MOVS     r0,#0x17
000036  2101              MOVS     r1,#1
000038  4081              LSLS     r1,r1,r0
00003a  4a1f              LDR      r2,|L4.184|
00003c  6011              STR      r1,[r2,#0]
00003e  bf00              NOP      
;;;155    
;;;156        /* start to IN data */
;;;157        g_u8EP2Ready = 1;
000040  2001              MOVS     r0,#1
000042  491e              LDR      r1,|L4.188|
000044  7008              STRB     r0,[r1,#0]
;;;158    
;;;159    #if CRYSTAL_LESS
;;;160        /* Backup default trim value */
;;;161        u32TrimInit = M32(TRIM_INIT);
000046  4819              LDR      r0,|L4.172|
000048  6904              LDR      r4,[r0,#0x10]
;;;162    
;;;163        /* Clear SOF */
;;;164        USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
00004a  2010              MOVS     r0,#0x10
00004c  491c              LDR      r1,|L4.192|
00004e  6048              STR      r0,[r1,#4]
;;;165    #endif
;;;166    
;;;167        while (1)
000050  e02b              B        |L4.170|
                  |L4.82|
;;;168        {
;;;169    #if CRYSTAL_LESS
;;;170    
;;;171            /* Start USB trim function if it is not enabled. */
;;;172            if ((SYS->IRCTCTL & SYS_IRCTCTL_FREQSEL_Msk) != 0x2)
000052  4816              LDR      r0,|L4.172|
000054  3880              SUBS     r0,r0,#0x80
000056  6800              LDR      r0,[r0,#0]
000058  0780              LSLS     r0,r0,#30
00005a  0f80              LSRS     r0,r0,#30
00005c  2802              CMP      r0,#2
00005e  d010              BEQ      |L4.130|
;;;173            {
;;;174                /* Start USB trim only when USB signal arrived */
;;;175                if (USBD->INTSTS & USBD_INTSTS_SOFIF_Msk)
000060  4817              LDR      r0,|L4.192|
000062  6840              LDR      r0,[r0,#4]
000064  2110              MOVS     r1,#0x10
000066  4008              ANDS     r0,r0,r1
000068  2800              CMP      r0,#0
00006a  d00a              BEQ      |L4.130|
;;;176                {
;;;177                    /* Clear SOF */
;;;178                    USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
00006c  2010              MOVS     r0,#0x10
00006e  4914              LDR      r1,|L4.192|
000070  6048              STR      r0,[r1,#4]
;;;179    
;;;180                    /* Enable USB clock trim function */
;;;181                    SYS->IRCTCTL |= (SYS_IRCTCTL_REFCKSEL_Msk | 0x2);
000072  480e              LDR      r0,|L4.172|
000074  3880              SUBS     r0,r0,#0x80
000076  6800              LDR      r0,[r0,#0]
000078  4912              LDR      r1,|L4.196|
00007a  4308              ORRS     r0,r0,r1
00007c  490b              LDR      r1,|L4.172|
00007e  3980              SUBS     r1,r1,#0x80
000080  6008              STR      r0,[r1,#0]
                  |L4.130|
;;;182                }
;;;183            }
;;;184    
;;;185            /* Disable USB Trim when any error found */
;;;186            if (SYS->IRCTISTS & (SYS_IRCTISTS_CLKERRIF_Msk | SYS_IRCTISTS_TFAILIF_Msk))
000082  480a              LDR      r0,|L4.172|
000084  3880              SUBS     r0,r0,#0x80
000086  6880              LDR      r0,[r0,#8]
000088  2106              MOVS     r1,#6
00008a  4008              ANDS     r0,r0,r1
00008c  2800              CMP      r0,#0
00008e  d00a              BEQ      |L4.166|
;;;187            {
;;;188                /* Init TRIM */
;;;189                M32(TRIM_INIT) = u32TrimInit;
000090  4806              LDR      r0,|L4.172|
000092  6104              STR      r4,[r0,#0x10]
;;;190    
;;;191                /* Disable USB clock trim function */
;;;192                SYS->IRCTCTL = 0;
000094  2000              MOVS     r0,#0
000096  4905              LDR      r1,|L4.172|
000098  3980              SUBS     r1,r1,#0x80
00009a  6008              STR      r0,[r1,#0]
;;;193    
;;;194                /* Clear trim error flags */
;;;195                SYS->IRCTISTS = SYS_IRCTISTS_CLKERRIF_Msk | SYS_IRCTISTS_TFAILIF_Msk;
00009c  2006              MOVS     r0,#6
00009e  6088              STR      r0,[r1,#8]
;;;196    
;;;197                /* Clear SOF */
;;;198                USBD_CLR_INT_FLAG(USBD_INTSTS_SOFIF_Msk);
0000a0  2010              MOVS     r0,#0x10
0000a2  4907              LDR      r1,|L4.192|
0000a4  6048              STR      r0,[r1,#4]
                  |L4.166|
;;;199    
;;;200            }
;;;201    
;;;202    #endif
;;;203            HID_UpdateKbData();
0000a6  f7fffffe          BL       HID_UpdateKbData
                  |L4.170|
0000aa  e7d2              B        |L4.82|
;;;204        }
;;;205    }
;;;206    
                          ENDP

                  |L4.172|
                          DCD      0x50000100
                  |L4.176|
                          DCD      HID_ClassRequest
                  |L4.180|
                          DCD      gsInfo
                  |L4.184|
                          DCD      0xe000e100
                  |L4.188|
                          DCD      g_u8EP2Ready
                  |L4.192|
                          DCD      0x40060000
                  |L4.196|
                          DCD      0x00000402

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8EP2Ready
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  u32PreKey
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6dbc9832____REV16|
#line 388 ".\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_6dbc9832____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6dbc9832____REVSH|
#line 402
|__asm___6_main_c_6dbc9832____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
